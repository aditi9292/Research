
\section{Tactical Clone Recommendation a Fundamental Step to More Reliable Software}
Based on the observations from the case study, we propose the concept of \emph{architectural clone} as the first step toward a practical tactical code reusability. The ultimate goal of our research is to develop a tactic recommender system. Previously we have developed a number of recommender systems to help domain analysts in early requirements engineering phase of software and also architecture recommender system to assist designers to identify right tactical choices during implementation. However, as discussed in the previous section the problem of recommending tactical code is far more challenging than the previous systems.

In this paper we show that the tactical clones are a promising direction in implementing such code recommender system.  The following section describes pieces of our techniques.

\subsection{Tactic Detection Engine}

In order to detect security tactics in source code, we will build on a novel, code-based classification technique that we previously developed for detecting architectural tactics in  source code \cite{Dissertation}. This Tactic Detector's classifiers (illustrated in figure \ref{fig:Archie}) have been trained to detect tactics such as audit, asynchronous method invocation, authentication, checkpoint, heartbeat, role-based access control (RBAC), resource pooling, scheduler, hash-based method authentication, and secure session.




 The classifiers are trained using code snippets representing different architectural tactics collected from hundreds of high-performance, open-source projects \cite{FSE2012,ICSE2012,Dissertation}.  During the training phase, the classifier learns the terms (method and variable names as well as development APIs) that developers typically use to implement each  tactic and assigns each potential indicator term a weight with respect to each type of  tactic. The weight estimates how strongly an indicator term indicates an architectural tactic. For instance, the term \emph{priority} is found more commonly in code related to the \emph{scheduling} tactic than in other kinds of code, and therefore the classifier assigns it a higher weighting with respect to scheduling. During the classification phase, the indicator terms are used to evaluate the likelihood that a given file implements an architectural tactic.
 
 
The accuracy of the Tactic Detector has been evaluated in several studies \cite{ICSE2012,FSE2014,Dissertation}.  In a series of  experiments it was able to correctly reject approximately 77-100\% of unrelated code classes (depending on tactic types), and to recall 100\% of the tactics-related classes in most cases, but only 70\% in the cases of the authentication, audit trail and asynchronous method invocation, and to achieve precision (at these recall levels) of 31\% and 61\% for RBAC and authentication, and from 65\% to 100\% for other tactics. Prior studies show that the Tactic Detector creates reliable results \cite{FSE2012,ICSE2012,Dissertation} and outperforms well known classification techniques such as decision tree algorithm (J48), AdaBoost, Bagging Algorithms and Support Vector Machine (SVM) \cite{Dissertation}.
