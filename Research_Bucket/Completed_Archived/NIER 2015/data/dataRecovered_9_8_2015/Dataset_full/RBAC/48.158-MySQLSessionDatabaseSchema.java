/*
 * Copyright (c) 2003 - 2008 OpenSubsystems s.r.o. Slovak Republic. All rights reserved.
 * 
 * Project: OpenSubsystems
 * 
 * $Id: MySQLSessionDatabaseSchema.java,v 1.24 2009/04/22 06:29:40 bastafidli Exp $
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

package org.opensubsystems.security.persist.db.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.persist.db.DatabaseSchemaManager;
import org.opensubsystems.core.persist.db.impl.DatabaseImpl;
import org.opensubsystems.core.util.CallContext;
import org.opensubsystems.core.util.GlobalConstants;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.StringUtils;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;
import org.opensubsystems.patterns.listdata.data.SimpleRule;
import org.opensubsystems.patterns.listdata.persist.db.ListDatabaseSchema;
import org.opensubsystems.patterns.listdata.persist.db.ListDatabaseUtils;
import org.opensubsystems.security.data.InternalSessionDataDescriptor;
import org.opensubsystems.security.persist.db.DomainDatabaseSchema;
import org.opensubsystems.security.persist.db.SessionDatabaseSchema;
import org.opensubsystems.security.persist.db.UserDatabaseSchema;

/**
 * Database specific operations related to persistence of sessions in MySQL.
 *
 * @version $Id: MySQLSessionDatabaseSchema.java,v 1.24 2009/04/22 06:29:40 bastafidli Exp $
 * @author Julo Legeny
 * @code.reviewer
 * @code.reviewed TODO: Review this code
 */
public class MySQLSessionDatabaseSchema extends SessionDatabaseSchema
{
   /*
      Use autogenerated numbers for IDs using AUTO_INCREMENT column.
      It automatically defines primary key
      Name all constraints to easily identify them later.
      There should be created index for each foreign key.
      All TIMESTAMP columns have to have constant default values otherwise MySQL
      will automatically update them with current timestamp every time record
      is modified.

      CREATE TABLE BF_INTERNAL_SESSION
      (
         ID INTEGER NOT NULL AUTO_INCREMENT,
         DOMAIN_ID INTEGER NOT NULL,
         USER_ID INTEGER NOT NULL,
         GEN_CODE VARCHAR(50) NOT NULL,
         CLIENT_IP VARCHAR(20) NOT NULL,
         CLIENT_TYPE VARCHAR(100) NULL,
         CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         GUEST_ACCESS INTEGER NOT NULL,
         CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE),
         CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID),
         INDEX IND_ISESS_DOMAIN_ID (DOMAIN_ID),
         CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID)
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE
         INDEX IND_ISESS_USER_ID (DOMAIN_ID),
         CONSTRAINT BF_INTSES_UID_FK FOREIGN KEY (USER_ID)
            REFERENCES BF_USER (ID) ON DELETE CASCADE
       ) TYPE=INNODB

      Create combined index DOMAIN_ID with COLUMN that can be 
      used for sorting in the list. There columns are specified by
      DEFAULT_LIST_COLUMNS constant and they are not disabled for 
      sorting within the RoleListTag class.
      
      CREATE INDEX LST_INTSIONCLINTIP ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_IP);
      CREATE INDEX LST_INTSIONCLITYPE ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_TYPE);
      CREATE INDEX LST_INTSIONCREDATE ON BF_INTERNAL_SESSION (DOMAIN_ID, CREATION_DATE);

      // Server IPhas to be long since we are storing there also
      // machine name which could have different length

      CREATE TABLE BF_EXTERNAL_SESSION
      (
         ID INTEGER NOT NULL AUTO_INCREMENT,
         DOMAIN_ID INTEGER NOT NULL,
         INTERNAL_SESSION_ID INTEGER NOT NULL,
         GEN_CODE VARCHAR(100) NOT NULL,
         SERVER VARCHAR(100) NOT NULL, 
         CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID),
         CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER),
         INDEX IND_ESESS_DOMAIN_ID (DOMAIN_ID),
         CONSTRAINT BF_EXTSES_DID_FK FOREIGN KEY (DOMAIN_ID) 
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         INDEX IND_ESESS_ISESSION_ID (INTERNAL_SESSION_ID),
         CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID)
            REFERENCES BF_INTERNAL_SESSION (ID) ON DELETE CASCADE
      ) TYPE=INNODB

   */

   // Constants ////////////////////////////////////////////////////////////////

   /**
    * Maximal length of internal session generated code.
    */
   public static final int INTSESSION_GEN_CODE_MAXLENGTH = InternalSessionDataDescriptor.INTSESSION_GENCODE_MAXLENGTH;

   /**
    * Maximal length of client IP.
    */
   public static final int INTSESSION_CLIENT_IP_MAXLENGTH = 20;

   /**
    * Maximal length of client type.
    */
   public static final int INTSESSION_CLIENT_TYPE_MAXLENGTH = 100;

   /**
    * Maximal length of external session generated code.
    */
   public static final int EXTSESSION_GEN_CODE_MAXLENGTH = 100;

   /**
    * Maximal length of server identification.
    * Server identification has to be long since we can be storing there IP
    * toether with machine name and port which could have different length
    */
   public static final int EXTSESSION_SERVER_MAXLENGTH = 100;

   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(MySQLSessionDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////

   // Constructors ////////////////////////////////////////////////////////////////

   /**
    * Default constructor.
    * 
    * @throws OSSException - an error has occurred
    */
   public MySQLSessionDatabaseSchema(
   ) throws OSSException
   {
      super();

      // Setup maximal length of individual fields for entities
      m_intSessionDescriptor.setInternalSessionMaxLength(INTSESSION_GEN_CODE_MAXLENGTH);
      m_intSessionDescriptor.setClientIPMaxLength(INTSESSION_CLIENT_IP_MAXLENGTH);
      m_intSessionDescriptor.setClientTypeMaxLength(INTSESSION_CLIENT_TYPE_MAXLENGTH);
      m_extSessionDescriptor.setServerSessionGenMaxLength(EXTSESSION_GEN_CODE_MAXLENGTH);
      m_extSessionDescriptor.setServerMaxLength(EXTSESSION_SERVER_MAXLENGTH);
   }

   // Logic ////////////////////////////////////////////////////////////////////

   /**
    * {@inheritDoc}
    */
   public void create(
      Connection cntDBConnection,
      String     strUserName
   ) throws SQLException, OSSException
   {
      Statement stmQuery = null;

      try
      {
         stmQuery = cntDBConnection.createStatement();
         if (stmQuery.execute(
            "create table " + INTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER NOT NULL AUTO_INCREMENT," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   USER_ID INTEGER NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + INTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," + NL +
            "   CLIENT_IP VARCHAR(" + INTSESSION_CLIENT_IP_MAXLENGTH + ") NOT NULL," + NL +
            "   CLIENT_TYPE VARCHAR(" + INTSESSION_CLIENT_TYPE_MAXLENGTH + ") NULL," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   GUEST_ACCESS INTEGER NOT NULL," + NL +
            "   CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE)," + NL +
            "   INDEX IND_ISESS_DOMAIN_ID (DOMAIN_ID)," + NL +
            "   CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE, " + NL +
            "   INDEX IND_ISESS_USER_ID (USER_ID)," + NL +
            "   CONSTRAINT BF_INTSES_UID_FK FOREIGN KEY (USER_ID) " + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }

         s_logger.log(Level.FINEST, "Table " + INTSESSION_TABLE_NAME + " created.");
/*
         if (stmQuery.execute("grant all on " + INTSESSION_TABLE_NAME + " to " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST,
                      "Access for table " + INTSESSION_TABLE_NAME + " set for user " + strUserName);
*/
         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + EXTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER NOT NULL AUTO_INCREMENT," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   INTERNAL_SESSION_ID INTEGER NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + EXTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," + NL +
            "   SERVER VARCHAR(" + EXTSESSION_SERVER_MAXLENGTH + ") NOT NULL," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER), " + NL +
            "   INDEX IND_ESESS_DOMAIN_ID (DOMAIN_ID)," + NL +
            "   CONSTRAINT BF_EXTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " + NL + 
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE, " + NL +
            "   INDEX IND_ESESS_ISESSION_ID (INTERNAL_SESSION_ID)," + NL +
            "   CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID) " + NL +
            "      REFERENCES " + INTSESSION_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }

         s_logger.log(Level.FINEST, "Table " + EXTSESSION_TABLE_NAME + " created.");
/*
         if (stmQuery.execute("grant all on " + EXTSESSION_TABLE_NAME + " to " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST,
                      "Access for table " + EXTSESSION_TABLE_NAME + " set for user " + strUserName);
*/

         ///////////////////////////////////////////////////////////////////////

         // create all combined indexes used for speeding up retrieving data into the list
         createListIndexes(cntDBConnection);

         ///////////////////////////////////////////////////////////////////////
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema " + SESSION_SCHEMA_NAME, sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertInternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();

      buffer.append("insert into " + INTSESSION_TABLE_NAME + "(ID, DOMAIN_ID, USER_ID, GEN_CODE, " +
               "CLIENT_IP, CLIENT_TYPE, GUEST_ACCESS, CREATION_DATE) " +
               "values (null, ?, ?, ?, ?, ?, ?, ");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(")");

      return buffer.toString();
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertExternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();

      buffer.append("insert into " + EXTSESSION_TABLE_NAME + "(DOMAIN_ID, INTERNAL_SESSION_ID, " +
                    "GEN_CODE, SERVER, CREATION_DATE) values (?, ?, ?, ?, ");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(")");

      return buffer.toString();
   }

   /**
    * {@inheritDoc}
    */
   public int updateEnable(
      Connection dbConnection,
      int[]      arrIds,
      int        iDomainId,
      boolean    bNewEnableValue,
      SimpleRule listSecurityData
   ) throws OSSException, SQLException
   {
      // TODO: MySQL 5: Version 4 doesn't support subqueries to split it into
      // two queries and run them separately
      PreparedStatement pstmSelect = null;
      PreparedStatement pstmUpdate = null;
      ResultSet         rsResults  = null;
      int               iUpdated = 0;
      List              lstLoggedInUsers = new ArrayList();
      List              lstPrepStmtArguments = new ArrayList();
      StringBuffer      buffer = new StringBuffer();

      // construct subquery
      buffer.append("select USER_ID from " + INTSESSION_TABLE_NAME + " where ");
      buffer.append(INTSESSION_TABLE_NAME + ".DOMAIN_ID = ? and " 
                    + INTSESSION_TABLE_NAME + ".ID in ");
      lstPrepStmtArguments.add(new Integer(iDomainId));
      DatabaseUtils.generatePreparedStatementPlaceholders(buffer, arrIds, 
                                                          lstPrepStmtArguments);

      // Select all currently logged in users and store their IDs within the list
      try
      {
         pstmSelect = dbConnection.prepareStatement(buffer.toString());
         DatabaseUtils.populatePreparedStatementPlaceholders(
                  pstmSelect, lstPrepStmtArguments);
         rsResults = pstmSelect.executeQuery();

         while (rsResults.next())
         {
            lstLoggedInUsers.add(new Integer(rsResults.getInt(1)));
         }
      }
      finally
      {
         DatabaseUtils.closeResultSetAndStatement(rsResults, pstmSelect);
      }

      // Construct main query
      if (!lstLoggedInUsers.isEmpty())
      {
         lstPrepStmtArguments.clear();
         buffer.delete(0, buffer.length());
         buffer.append("update " + UserDatabaseSchema.USER_TABLE_NAME 
                       + " set LOGIN_ENABLED = ?, MODIFICATION_DATE = ");
   
         lstPrepStmtArguments.add(bNewEnableValue ? GlobalConstants.INTEGER_1 
                                                  : GlobalConstants.INTEGER_0);
         
         buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
         buffer.append(ListDatabaseUtils.getInstance().getWhereClause(
                          UserDatabaseSchema.USER_TABLE_NAME, null, iDomainId, 
                          listSecurityData,
                          (ListDatabaseSchema)DatabaseSchemaManager.getInstance(
                             UserDatabaseSchema.class),
                          lstPrepStmtArguments));
         buffer.append(" and " + UserDatabaseSchema.USER_TABLE_NAME + ".ID in (");
         buffer.append(StringUtils.parseCollectionToString(lstLoggedInUsers, ","));
         buffer.append(")");
   
         try
         {
            pstmUpdate = dbConnection.prepareStatement(buffer.toString());
            DatabaseUtils.populatePreparedStatementPlaceholders(
                             pstmUpdate, lstPrepStmtArguments);
            iUpdated = pstmUpdate.executeUpdate();
         }
         finally
         {
            DatabaseUtils.closeStatement(pstmUpdate);
         }
      }

      return iUpdated;
   }

   /**
    * {@inheritDoc}
    */
   public int getActualUserCount(
      Connection dbConnection,
      int[]      arrIds,
      int        iDomainId,
      SimpleRule secData
   ) throws OSSException, SQLException
   {
      // TODO: MySQL 5: Version 4 doesn't support subqueries to split it into
      // two queries and run them separately
      PreparedStatement pstmQuery1 = null;
      PreparedStatement pstmQuery2 = null;
      ResultSet         rsResults  = null;
      int               iActual = 0;
      List              lstLoggedInUsers = new ArrayList();
      List              lstPrepStmtArguments = new ArrayList();
      StringBuffer      buffer = new StringBuffer();

      // construct subquery
      buffer.append("select " + INTSESSION_TABLE_NAME + ".USER_ID from " 
                    + INTSESSION_TABLE_NAME + " where " 
                    + INTSESSION_TABLE_NAME + ".DOMAIN_ID = ? and " 
                    + INTSESSION_TABLE_NAME + ".ID in ");
      lstPrepStmtArguments.add(new Integer(iDomainId));
      DatabaseUtils.generatePreparedStatementPlaceholders(buffer, arrIds, 
                                                          lstPrepStmtArguments);
      buffer.append(" group by " + INTSESSION_TABLE_NAME + ".USER_ID");

      // Select all currently logged in users and store their IDs within the list
      try
      {
         pstmQuery1 = dbConnection.prepareStatement(buffer.toString());
         DatabaseUtils.populatePreparedStatementPlaceholders(
                         pstmQuery1, lstPrepStmtArguments);
         rsResults = pstmQuery1.executeQuery();
         
         while (rsResults.next())
         {
            lstLoggedInUsers.add(new Integer(rsResults.getInt(1)));
         }
      }
      finally
      {
         DatabaseUtils.closeResultSetAndStatement(rsResults, pstmQuery1);
      }

      // Construct main query
      if (!lstLoggedInUsers.isEmpty())
      {
         lstPrepStmtArguments.clear();
         buffer.delete(0, buffer.length());
         buffer.append("select count(" + UserDatabaseSchema.USER_TABLE_NAME 
                       + ".ID) from " + UserDatabaseSchema.USER_TABLE_NAME + " ");
         buffer.append(ListDatabaseUtils.getInstance().getWhereClause(
                          UserDatabaseSchema.USER_TABLE_NAME, null, iDomainId, secData, 
                          m_userSchema, lstPrepStmtArguments));
         buffer.append(" and " + UserDatabaseSchema.USER_TABLE_NAME + ".ID in (");
         buffer.append(StringUtils.parseCollectionToString(lstLoggedInUsers, ","));
         buffer.append(")");
   
         try
         {
            pstmQuery2 = dbConnection.prepareStatement(buffer.toString());
            DatabaseUtils.populatePreparedStatementPlaceholders(
                             pstmQuery1, lstPrepStmtArguments);
            iActual = DatabaseUtils.loadAtMostOneInt(pstmQuery2, iActual,
                         "Unexpected error loading count.");
         }
         finally
         {
            DatabaseUtils.closeStatement(pstmQuery1);
            DatabaseUtils.closeStatement(pstmQuery2);
         }
      }

      return iActual;
   }

   /**
    * {@inheritDoc}
    */
   public int getCountOfNotContainedSuperUsers(
      Connection dbConnection,
      int[]      arrIds
   ) throws OSSException, SQLException
   {
      // TODO: MySQL 5: Version 4 doesn't support subqueries to split it into
      // two queries and run them separately
      PreparedStatement pstmQuery1 = null;
      PreparedStatement pstmQuery2 = null;
      ResultSet         rsResults  = null;
      int               iCount = 0;
      int               iDomainId = CallContext.getInstance().getCurrentDomainId();
      List              lstLoggedInUserIDs = new ArrayList();
      List              lstPrepStmtArguments = new ArrayList();
      StringBuffer      buffer = new StringBuffer();

      // construct subquery
      buffer.append("select USER_ID from " + INTSESSION_TABLE_NAME + " where " + 
                    "DOMAIN_ID = ? and ID in ");
      lstPrepStmtArguments.add(new Integer(iDomainId));
      DatabaseUtils.generatePreparedStatementPlaceholders(buffer, arrIds, 
                                                          lstPrepStmtArguments);
      buffer.append(" group by USER_ID");

      // Select all currently logged in users and store their IDs within the list
      try
      {
         pstmQuery1 = dbConnection.prepareStatement(buffer.toString());
         DatabaseUtils.populatePreparedStatementPlaceholders(
                          pstmQuery1, lstPrepStmtArguments);
         rsResults = pstmQuery1.executeQuery();

         while (rsResults.next())
         {
            lstLoggedInUserIDs.add(new Integer(rsResults.getInt(1)));
         }
      }
      finally
      {
         DatabaseUtils.closeResultSetAndStatement(rsResults, pstmQuery1);
      }

      // Construct main query
      buffer.delete(0, buffer.length());
      buffer.append("select count(ID) from " + 
                    UserDatabaseSchema.USER_TABLE_NAME + 
                    " where SUPER_USER = 1 " +
                    "and DOMAIN_ID = ?");
      if (!lstLoggedInUserIDs.isEmpty())
      {
         buffer.append(" and ID not in (");
         buffer.append(StringUtils.parseCollectionToString(lstLoggedInUserIDs, ","));
         buffer.append(")");
      }

      try
      {
         pstmQuery2 = dbConnection.prepareStatement(buffer.toString());
         pstmQuery2.setInt(1, iDomainId);
         iCount = DatabaseUtils.loadAtMostOneInt(pstmQuery2, iCount,
                      "Unexpected error loading count.");
      }
      finally
      {
         DatabaseUtils.closeStatement(pstmQuery2);
      }

      return iCount;
   }

   /**
    * {@inheritDoc}
    */
   public boolean isExistingIndex(
      String strIndexName
   )
   {
      // find out if there has to be used combined index for retrieving 
      // this data object into the list
      if ((strIndexName.equals("LST_INTSIONCLINTIP"))
         || (strIndexName.equals("LST_INTSIONCLITYPE"))
         || (strIndexName.equals("LST_INTSIONCREDATE")))
      {
         return true;
      }
      else
      {
         return super.isExistingIndex(strIndexName);
      }
   }
}
