/*
 * Copyright (c) 2003 - 2008 OpenSubsystems s.r.o. Slovak Republic. All rights reserved.
 * 
 * Project: OpenSubsystems
 * 
 * $Id: SybaseSessionDatabaseSchema.java,v 1.21 2009/04/22 06:29:40 bastafidli Exp $
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

package org.opensubsystems.security.persist.db.sybase;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.util.CallContext;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.StringUtils;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;
import org.opensubsystems.patterns.listdata.data.SimpleRule;
import org.opensubsystems.patterns.listdata.persist.db.ListDatabaseUtils;
import org.opensubsystems.security.data.InternalSessionDataDescriptor;
import org.opensubsystems.security.persist.db.DomainDatabaseSchema;
import org.opensubsystems.security.persist.db.SessionDatabaseSchema;
import org.opensubsystems.security.persist.db.UserDatabaseSchema;

/**
 * Database specific operations related to persistence of sessions in Sybase ASE.
 *
 * @version $Id: SybaseSessionDatabaseSchema.java,v 1.21 2009/04/22 06:29:40 bastafidli Exp $
 * @author Julo Legeny
 * @code.reviewer 
 * @code.reviewed TODO: Review this code
 */
public class SybaseSessionDatabaseSchema extends SessionDatabaseSchema
{
   /*
      Database tables bfsession and srvsession database factories works with.
      Use autogenerated numbers for IDs using sequence
      Name all constraints to easily identify them later.
      ON DELETE CASCADE must be provided by trigger (but there can by just 1 
      delete trigger for the table). There will be not used triggers and all
      dala will be deleted manually.


      CREATE TABLE BF_INTERNAL_SESSION
      (
         ID NUMERIC(10, 0) IDENTITY NOT NULL,
         DOMAIN_ID NUMERIC(10, 0) NOT NULL,
         USER_ID NUMERIC(10, 0) NOT NULL,
         GEN_CODE VARCHAR(50) NOT NULL,
         CLIENT_IP VARCHAR(20) NOT NULL,
         CLIENT_TYPE VARCHAR(100) NULL,
         CREATION_DATE DATETIME NOT NULL,
         GUEST_ACCESS SMALLINT NOT NULL,
         CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID),
         CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE),
         CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID)
            REFERENCES BF_DOMAIN (ID),
         CONSTRAINT BF_INTSES_UID_FK FOREIGN KEY (USER_ID)
            REFERENCES BF_USER (ID)
      )

      Create combined index DOMAIN_ID with COLUMN that can be 
      used for sorting in the list. There columns are specified by
      DEFAULT_LIST_COLUMNS constant and they are not disabled for 
      sorting within the RoleListTag class.
      
      CREATE INDEX LST_INTSIONCLINTIP ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_IP);
      CREATE INDEX LST_INTSIONCLITYPE ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_TYPE);
      CREATE INDEX LST_INTSIONCREDATE ON BF_INTERNAL_SESSION (DOMAIN_ID, CREATION_DATE);

      CREATE PROCEDURE INSERT_BF_INTERNAL_SESSION
          @IN_DOMAIN_ID NUMERIC(10, 0), 
          @IN_USER_ID NUMERIC(10, 0),
          @IN_GEN_CODE VARCHAR(50),
          @IN_CLIENT_IP VARCHAR(20),
          @IN_CLIENT_TYPE VARCHAR(100),
          @IN_GUEST_ACCESS SMALLINT, 
          @OUT_KEY INTEGER OUTPUT,
          @OUT_TIMESTAMP DATETIME OUTPUT
      AS
         SET @OUT_TIMESTAMP = GETDATE()
         INSERT INTO " + strUserName + ".BF_INTERNAL_SESSION(DOMAIN_ID, USER_ID,  
            GEN_CODE, CLIENT_IP, CLIENT_TYPE, CREATION_DATE, GUEST_ACCESS)
             VALUES (@IN_DOMAIN_ID, @IN_USER_ID, @IN_GEN_CODE, @IN_CLIENT_IP, 
             @IN_CLIENT_TYPE, @OUT_TIMESTAMP, @IN_GUEST_ACCESS)
         SET @OUT_KEY = @@IDENTITY
      RETURN


      CREATE TABLE BF_EXTERNAL_SESSION
      (
         ID NUMERIC(10, 0) IDENTITY NOT NULL,
         DOMAIN_ID NUMERIC(10, 0) NOT NULL,
         INTERNAL_SESSION_ID NUMERIC(10, 0) NOT NULL,
         GEN_CODE VARCHAR(100) NOT NULL,
         SERVER VARCHAR(100) NOT NULL,
         CREATION_DATE DATETIME NOT NULL,
         CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID),
         CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER),
         CONSTRAINT BF_EXTSES_DID_FK FOREIGN KEY (DOMAIN_ID)
            REFERENCES BF_DOMAIN (ID),
         CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID)
            REFERENCES BF_INTERNAL_SESSION (ID)
      )


      CREATE PROCEDURE INSERT_BF_EXTERNAL_SESSION
          @IN_DOMAIN_ID NUMERIC(10, 0), 
          @IN_INTERNAL_SESSION_ID NUMERIC(10, 0),
          @IN_GEN_CODE VARCHAR(100),
          @IN_SERVER VARCHAR(100),
          @OUT_KEY INTEGER OUTPUT,
          @OUT_TIMESTAMP DATETIME OUTPUT
      AS
         SET @OUT_TIMESTAMP = GETDATE()
         INSERT INTO " + strUserName + ".BF_EXTERNAL_SESSION(DOMAIN_ID, 
             INTERNAL_SESSION_ID, GEN_CODE, SERVER, CREATION_DATE)
            VALUES (@IN_DOMAIN_ID, @IN_INTERNAL_SESSION_ID, @IN_GEN_CODE,  
            @IN_SERVER, @OUT_TIMESTAMP)
         SET @OUT_KEY = @@IDENTITY
      RETURN

   */

   // Constants ////////////////////////////////////////////////////////////////

   /**
    * Maximal length of internal session generated code.
    */
   public static final int INTSESSION_GEN_CODE_MAXLENGTH = InternalSessionDataDescriptor.INTSESSION_GENCODE_MAXLENGTH;

   /**
    * Maximal length of client IP.
    */
   public static final int INTSESSION_CLIENT_IP_MAXLENGTH = 20;

   /**
    * Maximal length of client type.
    */
   public static final int INTSESSION_CLIENT_TYPE_MAXLENGTH = 100;

   /**
    * Maximal length of external session generated code.
    */
   public static final int EXTSESSION_GEN_CODE_MAXLENGTH = 100;

   /**
    * Maximal length of server identification.
    * Server identification has to be long since we can be storing there IP
    * toether with machine name and port which could have different length
    */
   public static final int EXTSESSION_SERVER_MAXLENGTH = 100;

   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(SybaseSessionDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////

   /**
    * Default constructor.
    * 
    * @throws OSSException - an error has occurred
    */
   public SybaseSessionDatabaseSchema(
   ) throws OSSException
   {
      super();
      
      // Setup maximal length of individual fields for entities
      m_intSessionDescriptor.setInternalSessionMaxLength(INTSESSION_GEN_CODE_MAXLENGTH);
      m_intSessionDescriptor.setClientIPMaxLength(INTSESSION_CLIENT_IP_MAXLENGTH);
      m_intSessionDescriptor.setClientTypeMaxLength(INTSESSION_CLIENT_TYPE_MAXLENGTH);
      m_extSessionDescriptor.setServerSessionGenMaxLength(EXTSESSION_GEN_CODE_MAXLENGTH);
      m_extSessionDescriptor.setServerMaxLength(EXTSESSION_SERVER_MAXLENGTH);
   }

   // Logic /////////////////////////////////////////////////////////////////////

   /**
    * {@inheritDoc}
    */
   public void create(
      Connection cntDBConnection,
      String strUserName
   ) throws SQLException, OSSException
   {
      Statement stmQuery = null;
      try
      {
         stmQuery = cntDBConnection.createStatement();

         if (stmQuery.execute(
            "create table " + INTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID NUMERIC(10, 0) IDENTITY NOT NULL," + NL +
            "   DOMAIN_ID NUMERIC(10, 0) NOT NULL," + NL +
            "   USER_ID NUMERIC(10, 0) NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + INTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," +
            "   CLIENT_IP VARCHAR(" + INTSESSION_CLIENT_IP_MAXLENGTH + ") NULL," + NL +
            "   CLIENT_TYPE VARCHAR(" + INTSESSION_CLIENT_TYPE_MAXLENGTH + ") NULL," + NL +
            "   CREATION_DATE DATETIME NOT NULL," + NL +
            "   GUEST_ACCESS SMALLINT NOT NULL," + NL +
            "   CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE)," + NL +
            "   CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID)," + NL +
            "   CONSTRAINT BF_INTSES_FK FOREIGN KEY (USER_ID) " + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID)" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + INTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "CREATE PROCEDURE INSERT_" + INTSESSION_TABLE_NAME + NL +
            "   @IN_DOMAIN_ID NUMERIC(10, 0), " + NL +
            "   @IN_USER_ID NUMERIC(10, 0)," + NL +
            "   @IN_GEN_CODE VARCHAR(" + INTSESSION_GEN_CODE_MAXLENGTH + ")," + NL +
            "   @IN_CLIENT_IP VARCHAR(" + INTSESSION_CLIENT_IP_MAXLENGTH + ")," + NL +
            "   @IN_CLIENT_TYPE VARCHAR(" + INTSESSION_CLIENT_TYPE_MAXLENGTH + ")," + NL +
            "   @IN_GUEST_ACCESS SMALLINT, " + NL +
            "   @OUT_KEY INTEGER OUTPUT, " +
            "   @OUT_TIMESTAMP DATETIME OUTPUT " + NL +
            "AS " + NL +
            "   SET @OUT_TIMESTAMP = GETDATE() " + NL +
            "   INSERT INTO " + strUserName + "." + INTSESSION_TABLE_NAME + "(DOMAIN_ID, USER_ID, " + NL + 
            "      GEN_CODE, CLIENT_IP, CLIENT_TYPE, CREATION_DATE, GUEST_ACCESS)" + NL +
            "       VALUES (@IN_DOMAIN_ID, @IN_USER_ID, @IN_GEN_CODE, @IN_CLIENT_IP, " + NL +
            "       @IN_CLIENT_TYPE, @OUT_TIMESTAMP, @IN_GUEST_ACCESS) " + NL +
            "   SET @OUT_KEY = @@IDENTITY  " + NL +
            "RETURN"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Procedure INSERT_" + INTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + EXTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID NUMERIC(10, 0) IDENTITY NOT NULL," + NL +
            "   DOMAIN_ID NUMERIC(10, 0) NOT NULL," + NL +
            "   INTERNAL_SESSION_ID NUMERIC(10, 0) NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + EXTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," + NL +
            "   SERVER VARCHAR(" + EXTSESSION_SERVER_MAXLENGTH + ") NOT NULL," + NL +
            "   CREATION_DATE DATETIME NOT NULL," + NL +
            "   CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER)," + NL +
            "   CONSTRAINT BF_EXTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " +  NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID), " + NL +
            "   CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID) " + NL + 
            "      REFERENCES " + INTSESSION_TABLE_NAME + " (ID)" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + EXTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         // create all combined indexes used for speeding up retrieving data into the list
         createListIndexes(cntDBConnection);

         ///////////////////////////////////////////////////////////////////////
         
         if (stmQuery.execute(
            "CREATE PROCEDURE INSERT_" + EXTSESSION_TABLE_NAME + NL +
            "   @IN_DOMAIN_ID NUMERIC(10, 0), " +
            "   @IN_INTERNAL_SESSION_ID NUMERIC(10, 0)," + NL +
            "   @IN_GEN_CODE VARCHAR(" + EXTSESSION_GEN_CODE_MAXLENGTH + ")," + NL +
            "   @IN_SERVER VARCHAR(" + EXTSESSION_SERVER_MAXLENGTH + ")," + NL +
            "   @OUT_KEY INTEGER OUTPUT," + NL +
            "   @OUT_TIMESTAMP DATETIME OUTPUT" + NL +
            "AS " + NL +
            "   SET @OUT_TIMESTAMP = GETDATE() " + NL +
            "   INSERT INTO " + strUserName + "." + EXTSESSION_TABLE_NAME + "(DOMAIN_ID, " + NL +
            "       INTERNAL_SESSION_ID, GEN_CODE, SERVER, CREATION_DATE)" + NL +
            "      VALUES (@IN_DOMAIN_ID, @IN_INTERNAL_SESSION_ID, @IN_GEN_CODE,  " + NL +
            "      @IN_SERVER, @OUT_TIMESTAMP) " + NL +
            "   SET @OUT_KEY = @@IDENTITY " + NL +
            "RETURN"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Procedure INSERT_" + EXTSESSION_TABLE_NAME + " created.");
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema " + SESSION_SCHEMA_NAME, sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertInternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
       return "{call INSERT_" + INTSESSION_TABLE_NAME + " (?, ?, ?, ?, ?, ?, ?, ?)}";
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertExternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
       return "{call INSERT_" + EXTSESSION_TABLE_NAME + " (?, ?, ?, ?, ?, ?)}";
   }
  
   /**
    * {@inheritDoc}
    */
   public int deleteInternalSession(
      Connection dbConnection,
      String     strGenCode
   ) throws OSSException, SQLException
   {
      PreparedStatement pstmDelete = null;

      String strQuery = "";
      int iDeleted = 0;

      try
      {
         // delete all belonging external sessions
         strQuery = "delete from " + EXTSESSION_TABLE_NAME + " where INTERNAL_SESSION_ID in (" +
                    "select ID from " + INTSESSION_TABLE_NAME + " where GEN_CODE = ? and DOMAIN_ID = ?)";

         pstmDelete = dbConnection.prepareStatement(strQuery);
         pstmDelete.setString(1, strGenCode);
         pstmDelete.setInt(2, CallContext.getInstance().getCurrentDomainId());
         pstmDelete.executeUpdate();

         // delete internal session
         pstmDelete = dbConnection.prepareStatement(getDeleteInternalSessionByCode());
         pstmDelete.setString(1, strGenCode);
         pstmDelete.setInt(2, CallContext.getInstance().getCurrentDomainId());
         iDeleted = pstmDelete.executeUpdate();
      }
      finally
      {
         DatabaseUtils.closeStatement(pstmDelete);
      }
      
      return iDeleted;
   }
   
   /**
    * {@inheritDoc}
    */
   public int deleteInternalSessions(
      Connection        cntDBConnection,
      PreparedStatement pstmQuery,
      List              lstPrepStmtArguments,
      int[]             arrIds,
      int               iDomainId,
      SimpleRule        secData
   ) throws SQLException, OSSException
   {
      // TODO: Improve: Some of this code is repetitive in this class
      // as well as from getActualIds so try to reuse it
      
      // Since SybaseASE doesn't support cascade delete we will have to manually
      // delete related data
      PreparedStatement pstmSelect = null;
      ResultSet         rsResults = null;
      
      int          iDeleted = 0;
      List         lstIdsToDelete = new ArrayList();
      List         lstPrepStmtArgumentBuffer = new ArrayList();
      StringBuffer buffer = new StringBuffer();

      // Construct query for getting all internal session ids that will be deleted
      buffer.append("select ID from " + INTSESSION_TABLE_NAME + " ");
      buffer.append(ListDatabaseUtils.getInstance().getWhereClause(
                       INTSESSION_TABLE_NAME, arrIds, iDomainId, secData, 
                       this, lstPrepStmtArgumentBuffer));

      try
      {
         pstmSelect = cntDBConnection.prepareStatement(buffer.toString());
         DatabaseUtils.populatePreparedStatementPlaceholders(
                          pstmSelect, lstPrepStmtArgumentBuffer);
         rsResults = pstmSelect.executeQuery();
         while (rsResults.next())
         {
            lstIdsToDelete.add(new Integer(rsResults.getInt(1)));
         }
      }
      finally
      {
         DatabaseUtils.closeResultSetAndStatement(rsResults, pstmSelect);
      }

      if (lstIdsToDelete.isEmpty())
      {
         PreparedStatement pstmDelete = null;
         
         try
         {
            // Delete all external sessions belonging to the specified internal
            // sessions
            buffer.append("delete from " + EXTSESSION_TABLE_NAME 
                          + " where INTERNAL_SESSION_ID in (");
            buffer.append(StringUtils.parseCollectionToString(lstIdsToDelete, ","));
            buffer.append(")");
            pstmDelete = cntDBConnection.prepareStatement(buffer.toString());
            pstmDelete.executeUpdate();
         }
         finally
         {
            DatabaseUtils.closeStatement(pstmDelete);
         }
      
      
         iDeleted = super.deleteInternalSessions(cntDBConnection, pstmQuery,
                                                 lstPrepStmtArguments, arrIds, 
                                                 iDomainId, secData);
      }
      
      return iDeleted;
   }
   
   /**
    * {@inheritDoc}
    */
   public int deleteInternalSessionsForDomains(
      Connection        cntDBConnection,
      PreparedStatement pstmQuery,
      List              lstPrepStmtArguments,
      int[]             arrDomainIds,
      SimpleRule        secData
   ) throws SQLException, 
            OSSException
   {
      // TODO: Improve: Some of this code is repetitive in this class
      // as well as from getActualIds so try to reuse it
      
      // Since SybaseASE doesn't support cascade delete we will have to manually
      // delete related data
      PreparedStatement pstmSelect = null;
      ResultSet         rsResults = null;
      
      int          iDeleted = 0;
      List         lstIdsToDelete = new ArrayList();
      List         lstPrepStmtArgumentBuffer = new ArrayList();
      StringBuffer buffer = new StringBuffer();

      // Construct query for getting all internal session ids that will be deleted
      buffer.append("select ID from " + INTSESSION_TABLE_NAME + " ");
      buffer.append(ListDatabaseUtils.getInstance().getWhereClause(
                       INTSESSION_TABLE_NAME, null, arrDomainIds, secData, 
                       this, lstPrepStmtArgumentBuffer));

      try
      {
         pstmSelect = cntDBConnection.prepareStatement(buffer.toString());
         DatabaseUtils.populatePreparedStatementPlaceholders(
                          pstmSelect, lstPrepStmtArgumentBuffer);
         rsResults = pstmSelect.executeQuery();
         while (rsResults.next())
         {
            lstIdsToDelete.add(new Integer(rsResults.getInt(1)));
         }
      }
      finally
      {
         DatabaseUtils.closeResultSetAndStatement(rsResults, pstmSelect);
      }

      if (lstIdsToDelete.isEmpty())
      {
         PreparedStatement pstmDelete = null;
         
         try
         {
            // Delete all external sessions belonging to the specified internal
            // sessions
            buffer.append("delete from " + EXTSESSION_TABLE_NAME 
                          + " where INTERNAL_SESSION_ID in (");
            buffer.append(StringUtils.parseCollectionToString(lstIdsToDelete, ","));
            buffer.append(")");
            pstmDelete = cntDBConnection.prepareStatement(buffer.toString());
            pstmDelete.executeUpdate();
         }
         finally
         {
            DatabaseUtils.closeStatement(pstmDelete);
         }
      
         iDeleted = super.deleteInternalSessionsForDomains(cntDBConnection, 
                                                           pstmQuery, 
                                                           lstPrepStmtArguments, 
                                                           arrDomainIds,
                                                           secData);
      }
      
      return iDeleted;
   }
}
