/*
 * Copyright (c) 2003 - 2008 OpenSubsystems s.r.o. Slovak Republic. All rights reserved.
 * 
 * Project: OpenSubsystems
 * 
 * $Id: PostgreSQLSessionDatabaseSchema.java,v 1.13 2009/04/22 06:29:23 bastafidli Exp $
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

package org.opensubsystems.security.persist.db.postgresql;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;
import org.opensubsystems.security.data.InternalSessionDataDescriptor;
import org.opensubsystems.security.persist.db.DomainDatabaseSchema;
import org.opensubsystems.security.persist.db.SessionDatabaseSchema;
import org.opensubsystems.security.persist.db.UserDatabaseSchema;

/**
 * Database specific operations related to persistence of sessions in Postgre SQL.
 *
 * @version $Id: PostgreSQLSessionDatabaseSchema.java,v 1.13 2009/04/22 06:29:23 bastafidli Exp $
 * @author Julo Legeny
 * @code.reviewer
 * @code.reviewed TODO: Review this code
 */
public class PostgreSQLSessionDatabaseSchema extends SessionDatabaseSchema
{
   /*
      Database tables bfsession and srvsession database factories works with.
      Use autogenerated numbers for IDs using sequence
      Name all constraints to easily identify them later.

      CREATE TABLE BF_INTERNAL_SESSION
      (
         ID SERIAL,
         DOMAIN_ID INTEGER NOT NULL,
         USER_ID INTEGER NOT NULL,
         GEN_CODE VARCHAR(50) NOT NULL,
         CLIENT_IP VARCHAR(20) NOT NULL,
         CLIENT_TYPE VARCHAR(100) NULL,
         CREATION_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
         GUEST_ACCESS SMALLINT NOT NULL,
         CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID),
         CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE),
         CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID)
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         CONSTRAINT BF_INTSES_UID_FK FOREIGN KEY (USER_ID)
            REFERENCES BF_USER (ID) ON DELETE CASCADE
      );

      Create combined index DOMAIN_ID with COLUMN that can be 
      used for sorting in the list. There columns are specified by
      DEFAULT_LIST_COLUMNS constant and they are not disabled for 
      sorting within the RoleListTag class.
      
      CREATE INDEX LST_INTSIONCLINTIP ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_IP);
      CREATE INDEX LST_INTSIONCLITYPE ON BF_INTERNAL_SESSION (DOMAIN_ID, CLIENT_TYPE);
      CREATE INDEX LST_INTSIONCREDATE ON BF_INTERNAL_SESSION (DOMAIN_ID, CREATION_DATE);

      CREATE OR REPLACE FUNCTION INSERT_BF_INTERNAL_SESSION 
      (
         INTEGER, 
         INTEGER,
         VARCHAR(50),
         VARCHAR(20),
         VARCHAR(100),
         INTEGER
      ) RETURNS type_int_timestamp AS '
      DECLARE
         IN_DOMAIN_ID ALIAS FOR $1;
         IN_USER_ID  ALIAS FOR $2;
         IN_GEN_CODE  ALIAS FOR $3;
         IN_CLIENT_IP  ALIAS FOR $4;
         IN_CLIENT_TYPE  ALIAS FOR $5;
         IN_GUEST_ACCESS  ALIAS FOR $6;
         out_key INTEGER;
         out_timestamp TIMESTAMP WITH TIME ZONE;
         output_result type_int_timestamp;
      BEGIN
         SELECT INTO out_timestamp now();
         INSERT INTO BF_INTERNAL_SESSION(DOMAIN_ID, USER_ID, GEN_CODE, CLIENT_IP, 
                CLIENT_TYPE, CREATION_DATE, GUEST_ACCESS)
             VALUES (IN_DOMAIN_ID, IN_USER_ID, IN_GEN_CODE, IN_CLIENT_IP, 
                IN_CLIENT_TYPE, out_timestamp, IN_GUEST_ACCESS);
         out_key := CURRVAL(''bf_internal_session_id_seq'');
         output_result.intgr := out_key;
         output_result.tmstp := out_timestamp;

         RETURN output_result;
      END;
      ' LANGUAGE 'plpgsql';

      CREATE TABLE BF_EXTERNAL_SESSION
      (
         ID SERIAL,
         DOMAIN_ID INTEGER NOT NULL,
         INTERNAL_SESSION_ID INTEGER NOT NULL,
         GEN_CODE VARCHAR(100) NOT NULL,
         SERVER VARCHAR(100) NOT NULL,
         CREATION_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
         CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID),
         CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER),
         CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID)
         REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID)
         REFERENCES BF_INTERNAL_SESSION (ID) ON DELETE CASCADE
      );

      CREATE OR REPLACE FUNCTION INSERT_BF_EXTERNAL_SESSION 
      (
         INTEGER, 
         INTEGER,
         VARCHAR(100),
         VARCHAR(100)
      ) RETURNS type_int_timestamp AS '
      DECLARE
         IN_DOMAIN_ID ALIAS FOR $1;
         IN_INTERNAL_SESSION_ID ALIAS FOR $2;
         IN_GEN_CODE ALIAS FOR $3;
         IN_SERVER ALIAS FOR $4;

         out_key INTEGER;
         out_timestamp TIMESTAMP WITH TIME ZONE;
         output_result type_int_timestamp;
      BEGIN
         SELECT INTO out_timestamp now();
          INSERT INTO BF_EXTERNAL_SESSION(DOMAIN_ID, INTERNAL_SESSION_ID, GEN_CODE, 
                 SERVER, CREATION_DATE)
             VALUES (IN_DOMAIN_ID, IN_INTERNAL_SESSION_ID, IN_GEN_CODE,  
                 IN_SERVER, out_timestamp);
         out_key := CURRVAL(''bf_external_session_id_seq'');
         output_result.intgr := out_key;
         output_result.tmstp := out_timestamp;

         RETURN output_result;
      END;
      ' LANGUAGE 'plpgsql';
   */

   // Constants ////////////////////////////////////////////////////////////////

   /**
    * Maximal length of internal session generated code.
    */
   public static final int INTSESSION_GEN_CODE_MAXLENGTH = InternalSessionDataDescriptor.INTSESSION_GENCODE_MAXLENGTH;

   /**
    * Maximal length of client IP.
    */
   public static final int INTSESSION_CLIENT_IP_MAXLENGTH = 20;

   /**
    * Maximal length of client type.
    */
   public static final int INTSESSION_CLIENT_TYPE_MAXLENGTH = 100;

   /**
    * Maximal length of external session generated code.
    */
   public static final int EXTSESSION_GEN_CODE_MAXLENGTH = 100;

   /**
    * Maximal length of server identification.
    * Server identification has to be long since we can be storing there IP
    * toether with machine name and port which could have different length
    */
   public static final int EXTSESSION_SERVER_MAXLENGTH = 100;

   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(PostgreSQLSessionDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////

   /**
    * Default constructor.
    * 
    * @throws OSSException - an error has occurred
    */
   public PostgreSQLSessionDatabaseSchema(
   ) throws OSSException
   {
      super();

      // Setup maximal length of individual fields for entities
      m_intSessionDescriptor.setInternalSessionMaxLength(INTSESSION_GEN_CODE_MAXLENGTH);
      m_intSessionDescriptor.setClientIPMaxLength(INTSESSION_CLIENT_IP_MAXLENGTH);
      m_intSessionDescriptor.setClientTypeMaxLength(INTSESSION_CLIENT_TYPE_MAXLENGTH);
      m_extSessionDescriptor.setServerSessionGenMaxLength(EXTSESSION_GEN_CODE_MAXLENGTH);
      m_extSessionDescriptor.setServerMaxLength(EXTSESSION_SERVER_MAXLENGTH);
   }

   // Logic /////////////////////////////////////////////////////////////////////

   /**
    * {@inheritDoc}
    */
   public void create(
      Connection cntDBConnection,
      String strUserName
   ) throws SQLException, OSSException
   {
      Statement stmQuery = null;
      try
      {
         stmQuery = cntDBConnection.createStatement();

         if (stmQuery.execute(
            "create table " + INTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID SERIAL," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   USER_ID INTEGER NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + INTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," +
            "   CLIENT_IP VARCHAR(" + INTSESSION_CLIENT_IP_MAXLENGTH + ") NULL," + NL +
            "   CLIENT_TYPE VARCHAR(" + INTSESSION_CLIENT_TYPE_MAXLENGTH + ") NULL," + NL +
            "   CREATION_DATE TIMESTAMP WITH TIME ZONE NOT NULL," + NL +
            "   GUEST_ACCESS SMALLINT NOT NULL," + NL +
            "   CONSTRAINT BF_INTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_INTSES_UQ UNIQUE (GEN_CODE)," + NL +
            "   CONSTRAINT BF_INTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT BF_INTSES_FK FOREIGN KEY (USER_ID) " + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + INTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "CREATE OR REPLACE FUNCTION INSERT_" + INTSESSION_TABLE_NAME + NL +
            "( " + NL +
            "   INTEGER, " + NL +
            "   INTEGER, " + NL +
            "   VARCHAR(" + INTSESSION_GEN_CODE_MAXLENGTH + "), " + NL +
            "   VARCHAR(" + INTSESSION_CLIENT_IP_MAXLENGTH + "), " + NL +
            "   VARCHAR(" + INTSESSION_CLIENT_TYPE_MAXLENGTH + "), " + NL +
            "   INTEGER " + NL +
            ") RETURNS type_int_timestamp AS ' " + NL +
            "DECLARE " + NL +
            "   IN_DOMAIN_ID ALIAS FOR $1; " + NL +
            "   IN_USER_ID  ALIAS FOR $2; " + NL +
            "   IN_GEN_CODE  ALIAS FOR $3; " + NL +
            "   IN_CLIENT_IP  ALIAS FOR $4; " + NL +
            "   IN_CLIENT_TYPE  ALIAS FOR $5; " + NL +
            "   IN_GUEST_ACCESS  ALIAS FOR $6; " + NL +
            "   out_key INTEGER; " + NL +
            "   out_timestamp TIMESTAMP WITH TIME ZONE; " + NL +
            "   output_result type_int_timestamp; " + NL +
            "BEGIN " + NL +
            "   SELECT INTO out_timestamp now(); " + NL +
            "   INSERT INTO " + strUserName + "." + INTSESSION_TABLE_NAME + "(DOMAIN_ID, USER_ID, " + NL +
            "          GEN_CODE, CLIENT_IP, CLIENT_TYPE, CREATION_DATE, GUEST_ACCESS) " + NL +
            "      VALUES (IN_DOMAIN_ID, IN_USER_ID, IN_GEN_CODE, IN_CLIENT_IP, " + NL +
            "          IN_CLIENT_TYPE, out_timestamp, IN_GUEST_ACCESS); " + NL +
            "   out_key := CURRVAL(''" + INTSESSION_TABLE_NAME + "_id_seq''); " + NL +
            "   output_result.intgr := out_key; " + NL +
            "   output_result.tmstp := out_timestamp; " + NL +
            "   RETURN output_result; " + NL +
            "END; " + NL +
            "' LANGUAGE 'plpgsql';"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Function INSERT_" + INTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + EXTSESSION_TABLE_NAME + NL +
            "(" + NL +
            "   ID SERIAL," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   INTERNAL_SESSION_ID INTEGER NOT NULL," + NL +
            "   GEN_CODE VARCHAR(" + EXTSESSION_GEN_CODE_MAXLENGTH + ") NOT NULL," + NL +
            "   SERVER VARCHAR(" + EXTSESSION_SERVER_MAXLENGTH + ") NOT NULL," + NL +
            "   CREATION_DATE TIMESTAMP WITH TIME ZONE NOT NULL," + NL +
            "   CONSTRAINT BF_EXTSES_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT BF_EXTSES_UQ UNIQUE (GEN_CODE, SERVER)," + NL +
            "   CONSTRAINT BF_EXTSES_DID_FK FOREIGN KEY (DOMAIN_ID) " +  NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT BF_EXTSES_FK FOREIGN KEY (INTERNAL_SESSION_ID) " + NL + 
            "      REFERENCES " + INTSESSION_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + EXTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "CREATE OR REPLACE FUNCTION INSERT_" + EXTSESSION_TABLE_NAME + NL +
            "( " + NL +
            "   INTEGER, " + NL +
            "   INTEGER, " + NL +
            "   VARCHAR(" + EXTSESSION_GEN_CODE_MAXLENGTH + "), " + NL +
            "   VARCHAR(" + EXTSESSION_SERVER_MAXLENGTH + ") " + NL +
            ") RETURNS type_int_timestamp AS ' " + NL +
            "DECLARE " + NL +
            "   IN_DOMAIN_ID ALIAS FOR $1; " + NL +
            "   IN_INTERNAL_SESSION_ID ALIAS FOR $2; " + NL +
            "   IN_GEN_CODE ALIAS FOR $3; " + NL +
            "   IN_SERVER ALIAS FOR $4; " + NL +
            "   out_key INTEGER; " + NL +
            "   out_timestamp TIMESTAMP WITH TIME ZONE; " + NL +
            "   output_result type_int_timestamp; " + NL +
            "BEGIN " + NL +
            "   SELECT INTO out_timestamp now(); " + NL +
            "   INSERT INTO " + strUserName + "." + EXTSESSION_TABLE_NAME + "(DOMAIN_ID, " + NL + 
            "          INTERNAL_SESSION_ID, GEN_CODE, SERVER, CREATION_DATE) " + NL +
            "       VALUES (IN_DOMAIN_ID, IN_INTERNAL_SESSION_ID, IN_GEN_CODE, " + NL +  
            "          IN_SERVER, out_timestamp); " + NL +
            "   out_key := CURRVAL(''" + EXTSESSION_TABLE_NAME + "_id_seq''); " + NL +
            "   output_result.intgr := out_key; " + NL +
            "   output_result.tmstp := out_timestamp; " + NL +
            "   RETURN output_result; " + NL +
            "END; " + NL +
            "' LANGUAGE 'plpgsql';"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Function INSERT_" + EXTSESSION_TABLE_NAME + " created.");

         ///////////////////////////////////////////////////////////////////////

         // create all combined indexes used for speeding up retrieving data into the list
         createListIndexes(cntDBConnection);

         ///////////////////////////////////////////////////////////////////////
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema " + SESSION_SCHEMA_NAME, sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertInternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
       return "select INTGR, TMSTP from INSERT_" + INTSESSION_TABLE_NAME + " (?, ?, ?, ?, ?, ?)";
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertExternalSessionAndFetchGeneratedValues(
   ) throws OSSException
   {
       return "select INTGR, TMSTP from INSERT_" + EXTSESSION_TABLE_NAME + " (?, ?, ?, ?)";
   }
}
