/*
 * Copyright (c) 2003 - 2008 OpenSubsystems s.r.o. Slovak Republic. All rights reserved.
 * 
 * Project: OpenSubsystems
 * 
 * $Id: HsqlDBRoleDatabaseSchema.java,v 1.22 2009/04/22 06:29:41 bastafidli Exp $
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

package org.opensubsystems.security.persist.db.hsqldb;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.persist.db.impl.DatabaseImpl;
import org.opensubsystems.core.util.GlobalConstants;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;
import org.opensubsystems.security.persist.db.DomainDatabaseSchema;
import org.opensubsystems.security.persist.db.RoleDatabaseSchema;
import org.opensubsystems.security.persist.db.UserDatabaseSchema;
import org.opensubsystems.security.util.RoleConstants;

/**
 * Database specific operations related to persistence of roles in HSQLDB.
 *
 * @version $Id: HsqlDBRoleDatabaseSchema.java,v 1.22 2009/04/22 06:29:41 bastafidli Exp $
 * @author Miro Halas
 * @code.reviewer Miro Halas
 * @code.reviewed Initial revision
 */
public class HsqlDBRoleDatabaseSchema extends RoleDatabaseSchema
{   
   /*
      Use autogenerated numbers for IDs using IDENTITY column.
      Identity automatically defines primary key
      Name all constraints to easily identify them later.
      For all unique constraint we need to define unique indexes instead of 
      unique constrant otherwise we won't be able to indentify the violation of
      this constraint by name. 

      create table BF_ROLE
      (
         ID INTEGER IDENTITY,
         DOMAIN_ID INTEGER NOT NULL,
         NAME VARCHAR(50) NOT NULL,
         DESCRIPTION VARCHAR(1024) NOT NULL,
         ENABLED INTEGER NOT NULL,
         USER_ID INTEGER DEFAULT NULL,
         UNMODIFIABLE TINYINT NOT NULL,
         CREATION_DATE TIMESTAMP NOT NULL,
         MODIFICATION_DATE TIMESTAMP NOT NULL,
         CONSTRAINT BF_ROLE_UQ UNIQUE (DOMAIN_ID, NAME),
         CONSTRAINT BF_ROLE_FK FOREIGN KEY (DOMAIN_ID) 
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         CONSTRAINT BF_ROLE_USER_FK FOREIGN KEY (USER_ID)
            REFERENCES BF_USER (ID) ON DELETE CASCADE
      );
      
      // We need to create unique index instead of the unique constraint otherwise
      // we are not able to detect it's violation by name  
      create unique index BF_ROLE_UQ on BF_ROLE (NAME)

      create table BF_ACCESS_RIGHT
      (
         ID INTEGER IDENTITY,
         ROLE_ID INTEGER NOT NULL,
         DOMAIN_ID INTEGER NOT NULL,
         ACTION INTEGER NOT NULL,
         DATA_TYPE INTEGER NOT NULL,
         RIGHT_TYPE INTEGER NOT NULL,
         CATEGORY INTEGER NOT NULL,
         IDENTIFIER INTEGER NOT NULL,
         CREATION_DATE TIMESTAMP NOT NULL,
         MODIFICATION_DATE TIMESTAMP NOT NULL,
         CONSTRAINT BF_ACCESS_RIGHT_ROLE_FK FOREIGN KEY (ROLE_ID) 
             REFERENCES BF_ROLE (ID) ON DELETE CASCADE,
         CONSTRAINT BF_ACCESS_RIGHT_DOMAIN_FK FOREIGN KEY (DOMAIN_ID) 
           REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE
      );
      
      create table BF_USER_ROLE_MAP
      (
         USER_ID INTEGER NOT NULL,      
         ROLE_ID INTEGER NOT NULL,
         CONSTRAINT BF_USER_ROLE_MAP_UQ UNIQUE (USER_ID,ROLE_ID),
         CONSTRAINT BF_USER_ROLE_MAP_FK1 FOREIGN KEY (USER_ID) 
            REFERENCES BF_USER (ID) ON DELETE CASCADE,
         CONSTRAINT BF_USER_ROLE_MAP_FK2 FOREIGN KEY (ROLE_ID) 
            REFERENCES BF_ROLE (ID) ON DELETE CASCADE
      );

      create table BF_DOMAIN_ROLE_MAP
      (
         DOMAIN_ID INTEGER NOT NULL,      
         ROLE_ID INTEGER NOT NULL,
         CONSTRAINT BF_DOM_ROL_MAP_UQ UNIQUE (DOMAIN_ID,ROLE_ID),
         CONSTRAINT BF_DOM_ROL_MAP_FK1 FOREIGN KEY (DOMAIN_ID) 
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         CONSTRAINT BF_DOM_ROL_MAP_FK2 FOREIGN KEY (ROLE_ID) 
            REFERENCES BF_ROLE (ID) ON DELETE CASCADE
      );
   */
   
   // Constants ////////////////////////////////////////////////////////////////

   /**
    * Maximal length of role name.
    */
   public static final int ROLE_NAME_MAXLENGTH = 50;

   /**
    * Maximal length of role description.
    */
   public static final int ROLE_DESCRIPTION_MAXLENGTH = 1024;

   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(HsqlDBRoleDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////

   /**
    * Default constructor.
    * 
    * @throws OSSException - error occurred.
    */
   public HsqlDBRoleDatabaseSchema(
   ) throws OSSException
   {
      super();

      // Setup maximal length of individual fields for entities
      m_roleDescriptor.setNameMaxLength(ROLE_NAME_MAXLENGTH);
      m_roleDescriptor.setDescriptionMaxLength(ROLE_DESCRIPTION_MAXLENGTH);
   }   

   // Public methods //////////////////////////////////////////////////////////

   /**
    * {@inheritDoc}
    */
   public void create(
      Connection cntDBConnection,
      String     strUserName
   ) throws SQLException, OSSException
   {
       
      Statement stmQuery = null;
      try
      {        
         stmQuery = cntDBConnection.createStatement();
         if (stmQuery.execute(
            "create table " + ROLE_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER IDENTITY," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   NAME VARCHAR(" + ROLE_NAME_MAXLENGTH + ") NOT NULL," + NL +
            "   DESCRIPTION VARCHAR(" + ROLE_DESCRIPTION_MAXLENGTH + ") NOT NULL," + NL +
            "   ENABLED INTEGER NOT NULL," + NL +
            "   USER_ID INTEGER DEFAULT NULL," + NL +
            "   UNMODIFIABLE TINYINT NOT NULL," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL," + NL +
            "   MODIFICATION_DATE TIMESTAMP NOT NULL," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_UQ UNIQUE (DOMAIN_ID, NAME)," +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_USER_FK FOREIGN KEY (USER_ID)" + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + ROLE_TABLE_NAME + " created.");
         
         if (stmQuery.execute("grant all on " + ROLE_TABLE_NAME + " TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + ROLE_TABLE_NAME + " set for user " + strUserName);
         
         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + ACCESSRIGHT_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER IDENTITY," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   ACTION INTEGER NOT NULL," + NL +
            "   DATA_TYPE INTEGER NOT NULL," + NL +
            "   RIGHT_TYPE INTEGER NOT NULL," + NL +
            "   CATEGORY INTEGER NOT NULL," + NL +
            "   IDENTIFIER INTEGER NOT NULL," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL," + NL +
            "   MODIFICATION_DATE TIMESTAMP NOT NULL," + NL +
            "   CONSTRAINT " + ACCESSRIGHT_TABLE_NAME + "_ROLE_FK FOREIGN KEY (ROLE_ID) " + NL + 
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT " + ACCESSRIGHT_TABLE_NAME + "_DOMAIN_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + ACCESSRIGHT_TABLE_NAME + " created.");
         
         if (stmQuery.execute("grant all on " + ACCESSRIGHT_TABLE_NAME + " TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + ACCESSRIGHT_TABLE_NAME + " set for user " + strUserName);
         
         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP" + NL +
            "(" + NL +
            "   USER_ID INTEGER NOT NULL," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_UQ UNIQUE (USER_ID,ROLE_ID)," + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_FK1 FOREIGN KEY (USER_ID) " + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_FK2 FOREIGN KEY (ROLE_ID) " + NL +
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP created.");
         
         if (stmQuery.execute("grant all on " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP set for user " + strUserName);

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP" + NL +
            "(" + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_UQ UNIQUE (DOMAIN_ID,ROLE_ID)," + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_FK1 FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_FK2 FOREIGN KEY (ROLE_ID) " + NL +
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ")"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP created.");
         
         if (stmQuery.execute("grant all on " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP set for user " + strUserName);

         ///////////////////////////////////////////////////////////////////////
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema " + ROLE_SCHEMA_NAME, sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertRoleAndFetchGeneratedValues(
   ) throws OSSException
   {
      return getInsertRole();      
   }

   /**
    * {@inheritDoc}
    */
   public String getUpdateRoleAndFetchGeneratedValues(
      boolean unmodifiable,
      int     roleType
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();
      
      // check if unmodifiable...
      if (unmodifiable)
      {
         buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, MODIFICATION_DATE = ");
         buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
         buffer.append(" where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
                       "and UNMODIFIABLE = ?");
      }
      else
      {
         switch (roleType)
         {
            case RoleConstants.SAVE_ROLE_NONPERSONAL : 
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                             "MODIFICATION_DATE = "); 
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? and " +
                             "MODIFICATION_DATE = ? and USER_ID is NULL and UNMODIFIABLE = ?");
               break;
            }
            case RoleConstants.SAVE_ROLE_PERSONAL :
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set MODIFICATION_DATE = "); 
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
                             "and USER_ID is NOT NULL and UNMODIFIABLE = ?");
               break;
            }
            case RoleConstants.SAVE_ROLE_ALWAYS : 
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                             "MODIFICATION_DATE = ");
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? " +
                             "and MODIFICATION_DATE = ? and UNMODIFIABLE = ?");
               break;
            }
            default :
            {
               if (GlobalConstants.ERROR_CHECKING)
               {
                  assert false : "Not supported type of role to save."; 
               }
            }
         }
      }

      return buffer.toString(); 
   }

   /**
    * {@inheritDoc}
    */
/*
   public Role updateRole(
      Connection dbConnection,
      Role       data,
      int        roleType
   ) throws OSSException
   {
      PreparedStatement updateStatement = null;
      int               iIndex = 1;
      
      try
      {
         // check if unmodifiable...
         if (data.isUnmodifiable())
         {
            updateStatement = dbConnection.prepareStatement(
               "update " + ROLE_TABLE_NAME + " set NAME = ?, MODIFICATION_DATE = now " + 
               "where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
               "and UNMODIFIABLE = ?"
            );
            updateStatement.setString(iIndex++, data.getName());
         }
         else
         {
            switch (roleType)
            {
               case RoleConstants.SAVE_ROLE_NONPERSONAL : 
               {
                  updateStatement = dbConnection.prepareStatement(
                     "update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                     "MODIFICATION_DATE = now where ID = ? and DOMAIN_ID = ? and " +
                     "MODIFICATION_DATE = ? and USER_ID is NULL and UNMODIFIABLE = ?"
                  );
                  break;
               }
               case RoleConstants.SAVE_ROLE_PERSONAL :
               {
                  updateStatement = dbConnection.prepareStatement(
                     "update " + ROLE_TABLE_NAME + " set MODIFICATION_DATE = now " + 
                     "where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
                     "and USER_ID is NOT NULL and UNMODIFIABLE = ?"
                  );
                  break;
               }
               case RoleConstants.SAVE_ROLE_ALWAYS : 
               {
                  updateStatement = dbConnection.prepareStatement(
                     "update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                     "MODIFICATION_DATE = now where ID = ? and DOMAIN_ID = ? " +
                     "and MODIFICATION_DATE = ? and UNMODIFIABLE = ?"
                  );
                  break;
               }
               default :
               {
                  if (GlobalConstants.ERROR_CHECKING)
                  {
                     assert false : "Not supported type of role to save."; 
                  }
               }
            }
            if (roleType != RoleConstants.SAVE_ROLE_PERSONAL)
            {
               updateStatement.setString(iIndex++, data.getName());
               updateStatement.setString(iIndex++, data.getDescription());
               updateStatement.setInt(iIndex++, data.isEnabled() ? 1 : 0);
            }
         }
         updateStatement.setInt(iIndex++, data.getId());
         // Here you must pass the domain id sent to you in data object
         // If you want to check if this id is the same as current domain id
         // do it at the controller level. 
         updateStatement.setInt(iIndex++, data.getDomainId());
         updateStatement.setTimestamp(iIndex++, data.getModificationTimestamp());
         updateStatement.setInt(iIndex++, data.isUnmodifiable() ? 1 : 0);
         HsqlDBDataUtils.updatedAndFetchGeneratedValues("Role", dbConnection,
                            updateStatement, isInDomain(), ROLE_TABLE_NAME, data);
      }
      catch (SQLException eExc)
      {
         // TODO: For Julo: Change this method updateRole() that will return only
         // command to prepared call, see getUpdateBlogAndFetchGeneratedValues() within
         // XXXBlogDatabaseSchema class
         handleSQLException(eExc, dbConnection, DatabaseUpdateOperation.DBOP_UPDATE,
                            DataConstant.ROLE_DATA_TYPE, data);

      }      
      finally 
      {
         DatabaseUtils.closeStatement(updateStatement);
      }
      
      return data;
   }
*/
   /**
    * {@inheritDoc}
    */
   public String getInsertAccessRightAndFetchGeneratedValues(
   ) throws OSSException
   {
      return getInsertAccessRight();
   }

   /**
    * {@inheritDoc} 
    */   
   public String getInsertAccessRight(
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();
      
      buffer.append("insert into " + ACCESSRIGHT_TABLE_NAME + "(ID, ROLE_ID, DOMAIN_ID, ACTION, " +
               "DATA_TYPE, RIGHT_TYPE, CATEGORY, IDENTIFIER, " +
               "CREATION_DATE, MODIFICATION_DATE) " +
               "values (null, ?, ?, ?, ?, ?, ?, ?, ");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(",");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(")");
   
      return buffer.toString();         
   }
}
