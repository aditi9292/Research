/*
 * Copyright (c) 2003 - 2008 OpenSubsystems s.r.o. Slovak Republic. All rights reserved.
 * 
 * Project: OpenSubsystems
 * 
 * $Id: MySQLRoleDatabaseSchema.java,v 1.29 2009/04/22 06:29:39 bastafidli Exp $
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. 
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

package org.opensubsystems.security.persist.db.mysql;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.persist.db.impl.DatabaseImpl;
import org.opensubsystems.core.util.GlobalConstants;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;
import org.opensubsystems.patterns.listdata.persist.db.ListDatabaseUtils;
import org.opensubsystems.security.persist.db.DomainDatabaseSchema;
import org.opensubsystems.security.persist.db.RoleDatabaseSchema;
import org.opensubsystems.security.persist.db.UserDatabaseSchema;
import org.opensubsystems.security.util.RoleConstants;

/**
 * Database specific operations related to persistence of roles in MySQL.
 *
 * @version $Id: MySQLRoleDatabaseSchema.java,v 1.29 2009/04/22 06:29:39 bastafidli Exp $
 * @author Miro Halas
 * @code.reviewer
 * @code.reviewer TODO: Review this code
 */
public class MySQLRoleDatabaseSchema extends RoleDatabaseSchema
{   
   /*
      Use autogenerated numbers for IDs using AUTO_INCREMENT column.
      It automatically defines primary key
      Name all constraints to easily identify them later.
      DESCRIPTION column must be type of TEXT because VARCHAR type 
      can be max. 255 characters length.
      There should be created index for each foreign key.
      All TIMESTAMP columns have to have constant default values otherwise MySQL
      will automatically update them with current timestamp every time record
      is modified.

      create table BF_ROLE
      (
         ID INTEGER NOT NULL AUTO_INCREMENT,
         DOMAIN_ID INTEGER NOT NULL,
         NAME VARCHAR(50) NOT NULL,
         DESCRIPTION TEXT NOT NULL,
         ENABLED INTEGER NOT NULL,
         USER_ID INTEGER DEFAULT NULL,
         UNMODIFIABLE TINYINT NOT NULL,
         MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CONSTRAINT BF_ROLE_PK PRIMARY KEY (ID),
         CONSTRAINT BF_ROLE_UQ UNIQUE (DOMAIN_ID, NAME),
         INDEX IND_ROLE_DOMAIN_ID (DOMAIN_ID),
         CONSTRAINT BF_ROLE_FK FOREIGN KEY (DOMAIN_ID) 
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         INDEX IND_ROLE_USER_ID (USER_ID),
         CONSTRAINT BF_ROLE_USER_FK FOREIGN KEY (USER_ID)
            REFERENCES BF_USER (ID) ON DELETE CASCADE
      ) TYPE=INNODB 
      

      create table BF_ACCESS_RIGHT
      (
         ID INTEGER NOT NULL AUTO_INCREMENT,
         ROLE_ID INTEGER NOT NULL,
         DOMAIN_ID INTEGER NOT NULL,
         ACTION INTEGER NOT NULL,
         DATA_TYPE INTEGER NOT NULL,
         RIGHT_TYPE INTEGER NOT NULL,
         CATEGORY INTEGER NOT NULL,
         IDENTIFIER INTEGER NOT NULL,
         MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CONSTRAINT BF_ACCESS_RIGHT_PK PRIMARY KEY (ID),
         INDEX IND_RIGHT_ROLE_ID (ROLE_ID),
         CONSTRAINT BF_ACCESS_RIGHT_ROLE_FK FOREIGN KEY (ROLE_ID) 
             REFERENCES BF_ROLE (ID) ON DELETE CASCADE,
         INDEX IND_RIGHT_DOMAIN_ID (DOMAIN_ID),
         CONSTRAINT BF_ACCESS_RIGHT_DOMAIN_FK FOREIGN KEY (DOMAIN_ID) 
           REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE
      ) TYPE=INNODB
      
      create table BF_USER_ROLE_MAP
      (
         USER_ID INTEGER NOT NULL,      
         ROLE_ID INTEGER NOT NULL,
         CONSTRAINT BF_USER_ROLE_MAP_UQ UNIQUE (USER_ID,ROLE_ID),
         INDEX IND_URMAP_USER_ID (USER_ID),
         CONSTRAINT BF_USER_ROLE_MAP_FK1 FOREIGN KEY (USER_ID) 
            REFERENCES BF_USER (ID) ON DELETE CASCADE,
         INDEX IND_URMAP_ROLE_ID (ROLE_ID),
         CONSTRAINT BF_USER_ROLE_MAP_FK2 FOREIGN KEY (ROLE_ID) 
            REFERENCES BF_ROLE (ID) ON DELETE CASCADE
      ) TYPE=INNODB
      
      create table BF_DOMAINR_ROLE_MAP
      (
         DOMAIN_ID INTEGER NOT NULL,      
         ROLE_ID INTEGER NOT NULL,
         CONSTRAINT BF_DOM_ROL_MAP_UQ UNIQUE (DOMAIN_ID,ROLE_ID),
         INDEX IND_DRMAP_DOMAIN_ID (DOMAIN_ID),
         CONSTRAINT BF_DOM_ROL_MAP_FK1 FOREIGN KEY (DOMAIN_ID) 
            REFERENCES BF_DOMAIN (ID) ON DELETE CASCADE,
         INDEX IND_DRMAP_ROLE_ID (ROLE_ID),
         CONSTRAINT BF_DOM_ROL_MAP_FK2 FOREIGN KEY (ROLE_ID) 
            REFERENCES BF_ROLE (ID) ON DELETE CASCADE
      ) TYPE=INNODB

      Create combined index DOMAIN_ID with COLUMN that can be 
      used for sorting in the list. There columns are specified by
      DEFAULT_LIST_COLUMNS constant and they are not disabled for 
      sorting within the RoleListTag class.
      
      CREATE INDEX LST_ROLENAME ON BF_ROLE (DOMAIN_ID, NAME);
      CREATE INDEX LST_ROLEENABLED ON BF_ROLE (DOMAIN_ID, ENABLED);
      CREATE INDEX LST_ROLEMODDATE ON BF_ROLE (DOMAIN_ID, MODIFICATION_DATE);
   */
   
   // Constants ////////////////////////////////////////////////////////////////

   /**
    * Maximal length of role name.
    */
   public static final int ROLE_NAME_MAXLENGTH = 50;

   /**
    * Maximal length of role description.
    */
   public static final int ROLE_DESCRIPTION_MAXLENGTH = 1024;

   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(MySQLRoleDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////

   /**
    * Default constructor.
    * 
    * @throws OSSException - error occurred.
    */
   public MySQLRoleDatabaseSchema(
   ) throws OSSException
   {
      super();

      // Setup maximal length of individual fields for entities
      m_roleDescriptor.setNameMaxLength(ROLE_NAME_MAXLENGTH);
      m_roleDescriptor.setDescriptionMaxLength(ROLE_DESCRIPTION_MAXLENGTH);
   }   

   // Public methods //////////////////////////////////////////////////////////

   /**
    * {@inheritDoc}
    */
   public void create(
      Connection cntDBConnection,
      String     strUserName
   ) throws SQLException, OSSException
   {
       
      Statement stmQuery = null;
      try
      {        
         stmQuery = cntDBConnection.createStatement();
         if (stmQuery.execute(
            "create table " + ROLE_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER NOT NULL AUTO_INCREMENT," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   NAME VARCHAR(" + ROLE_NAME_MAXLENGTH + ") NOT NULL," + NL +
            "   DESCRIPTION TEXT NOT NULL," + NL +
            "   ENABLED INTEGER NOT NULL," + NL +
            "   USER_ID INTEGER DEFAULT NULL," + NL +
            "   UNMODIFIABLE TINYINT NOT NULL," + NL +
            "   MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_PK PRIMARY KEY (ID)," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_UQ UNIQUE (DOMAIN_ID, NAME)," + NL +
            "   INDEX IND_ROLE_DOMAIN_ID (DOMAIN_ID)," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   INDEX IND_ROLE_USER_ID (USER_ID)," + NL +
            "   CONSTRAINT " + ROLE_TABLE_NAME + "_USER_FK FOREIGN KEY (USER_ID)" + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + ROLE_TABLE_NAME + " created.");
/*
         if (stmQuery.execute("grant all on " + ROLE_TABLE_NAME + " TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + ROLE_TABLE_NAME + " set for user " + strUserName);
*/
         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + ACCESSRIGHT_TABLE_NAME + NL +
            "(" + NL +
            "   ID INTEGER NOT NULL AUTO_INCREMENT," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   ACTION INTEGER NOT NULL," + NL +
            "   DATA_TYPE INTEGER NOT NULL," + NL +
            "   RIGHT_TYPE INTEGER NOT NULL," + NL +
            "   CATEGORY INTEGER NOT NULL," + NL +
            "   IDENTIFIER INTEGER NOT NULL," + NL +
            "   MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
            "   CONSTRAINT " + ACCESSRIGHT_TABLE_NAME + "_PK PRIMARY KEY (ID)," + NL +
            "   INDEX IND_RIGHT_ROLE_ID (ROLE_ID)," + NL +
            "   CONSTRAINT " + ACCESSRIGHT_TABLE_NAME + "_ROLE_FK FOREIGN KEY (ROLE_ID) " + NL + 
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   INDEX IND_RIGHT_DOMAIN_ID (DOMAIN_ID)," + NL +
            "   CONSTRAINT " + ACCESSRIGHT_TABLE_NAME + "_DOMAIN_FK FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + ACCESSRIGHT_TABLE_NAME + " created.");
/*
         if (stmQuery.execute("grant all on " + ACCESSRIGHT_TABLE_NAME + " TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + ACCESSRIGHT_TABLE_NAME + " set for user " + strUserName);
*/
         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP" + NL +
            "(" + NL +
            "   USER_ID INTEGER NOT NULL," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_UQ UNIQUE (USER_ID,ROLE_ID)," + NL +
            "   INDEX IND_URMAP_USER_ID (USER_ID)," + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_FK1 FOREIGN KEY (USER_ID) " + NL +
            "      REFERENCES " + UserDatabaseSchema.USER_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   INDEX IND_URMAP_ROLE_ID (ROLE_ID), " + NL +
            "   CONSTRAINT " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP_FK2 FOREIGN KEY (ROLE_ID) " + NL +
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP created.");
/*
         if (stmQuery.execute("grant all on " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + UserDatabaseSchema.USER_TABLE_NAME + "_ROLE_MAP set for user " + strUserName);
*/

         ///////////////////////////////////////////////////////////////////////

         if (stmQuery.execute(
            "create table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP" + NL +
            "(" + NL +
            "   DOMAIN_ID INTEGER NOT NULL," + NL +
            "   ROLE_ID INTEGER NOT NULL," + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_UQ UNIQUE (DOMAIN_ID,ROLE_ID)," + NL +
            "   INDEX IND_DRMAP_DOMAIN_ID (DOMAIN_ID)," + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_FK1 FOREIGN KEY (DOMAIN_ID) " + NL +
            "      REFERENCES " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + " (ID) ON DELETE CASCADE," + NL +
            "   INDEX IND_DRMAP_ROLE_ID (ROLE_ID), " + NL +
            "   CONSTRAINT BF_DOM_ROL_MAP_FK2 FOREIGN KEY (ROLE_ID) " + NL +
            "      REFERENCES " + ROLE_TABLE_NAME + " (ID) ON DELETE CASCADE" + NL +
            ") TYPE=INNODB"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP created.");
/*
         if (stmQuery.execute("grant all on " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP TO " + strUserName))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, 
                      "Access for table " + DomainDatabaseSchema.DOMAIN_TABLE_NAME + "_ROLE_MAP set for user " + strUserName);
*/

         ///////////////////////////////////////////////////////////////////////

         // create all combined indexes used for speeding up retrieving data into the list
         createListIndexes(cntDBConnection);

         ///////////////////////////////////////////////////////////////////////
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema " + ROLE_SCHEMA_NAME, sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }
   }

   /**
    * {@inheritDoc}
    */
   public void createListIndexes(
      Connection cntDBConnection
   ) throws SQLException, 
            OSSException
   {
      Statement stmQuery = null;
      String strIndexName = null;

      try
      {
         stmQuery = cntDBConnection.createStatement();
         // This index causes problem for Oracle because it is automatically indexed 
         // for unique column - therefore we have to specify it within each DB specific 
         // class.
         strIndexName = ListDatabaseUtils.getInstance().generateListIndexName(
                           ROLE_TABLE_NAME, "NAME");
         if (stmQuery.execute("CREATE INDEX " + strIndexName + " ON " + ROLE_TABLE_NAME + " (DOMAIN_ID, NAME)"))
         {
            // Close any results
            stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
         }
         s_logger.log(Level.FINEST, "Index " + strIndexName + " created.");
      }
      catch (SQLException sqleExc)
      {
         s_logger.log(Level.WARNING, 
                      "Failed to create schema LST indexes for Role data object", sqleExc);
         throw sqleExc;
      }
      finally
      {
         DatabaseUtils.closeStatement(stmQuery);
      }

      super.createListIndexes(cntDBConnection);
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertRoleAndFetchGeneratedValues(
   ) throws OSSException
   {
      return getInsertRole();      
   }

   /**
    * {@inheritDoc}
    */
   public String getUpdateRoleAndFetchGeneratedValues(
      boolean unmodifiable,
      int     roleType
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();
      
      // check if unmodifiable...
      if (unmodifiable)
      {
         buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, MODIFICATION_DATE = ");
         buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
         buffer.append(" where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
                       "and UNMODIFIABLE = ?");
      }
      else
      {
         switch (roleType)
         {
            case RoleConstants.SAVE_ROLE_NONPERSONAL : 
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                             "MODIFICATION_DATE = "); 
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? and " +
                             "MODIFICATION_DATE = ? and USER_ID is NULL and UNMODIFIABLE = ?");
               break;
            }
            case RoleConstants.SAVE_ROLE_PERSONAL :
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set MODIFICATION_DATE = "); 
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? and MODIFICATION_DATE = ? " +
                             "and USER_ID is NOT NULL and UNMODIFIABLE = ?");
               break;
            }
            case RoleConstants.SAVE_ROLE_ALWAYS : 
            {
               buffer.append("update " + ROLE_TABLE_NAME + " set NAME = ?, DESCRIPTION = ?, ENABLED = ?, " +
                             "MODIFICATION_DATE = ");
               buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
               buffer.append(" where ID = ? and DOMAIN_ID = ? " +
                             "and MODIFICATION_DATE = ? and UNMODIFIABLE = ?");
               break;
            }
            default :
            {
               if (GlobalConstants.ERROR_CHECKING)
               {
                  assert false : "Not supported type of role to save."; 
               }
            }
         }
      }

      return buffer.toString(); 
   }

   /**
    * {@inheritDoc}
    */
   public String getInsertAccessRightAndFetchGeneratedValues(
   ) throws OSSException
   {
      return getInsertAccessRight();
   }

   /**
    * {@inheritDoc} 
    */   
   public String getInsertAccessRight(
   ) throws OSSException
   {
      StringBuffer buffer = new StringBuffer();
      
      buffer.append("insert into " + ACCESSRIGHT_TABLE_NAME + "(ID, ROLE_ID, DOMAIN_ID, ACTION, " +
               "DATA_TYPE, RIGHT_TYPE, CATEGORY, IDENTIFIER, " +
               "CREATION_DATE, MODIFICATION_DATE) " +
               "values (null, ?, ?, ?, ?, ?, ?, ?, ");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(",");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(")");
   
      return buffer.toString();         
   }

   /**
    * {@inheritDoc}
    */
   public boolean isExistingIndex(
      String strIndexName
   )
   {
      // find out if there has to be used combined index for retrieving 
      // this data object into the list
      if ((strIndexName.equals("LST_ROLENAME"))
         || (strIndexName.equals("LST_ROLEENABLED"))
         || (strIndexName.equals("LST_ROLECREDATE"))
         || (strIndexName.equals("LST_ROLEMODDATE")))
      {
         return true;
      }
      else
      {
         return super.isExistingIndex(strIndexName);
      }
   }
}
