<source file="examples2/python//audioop.c.ifdefed" startline="53" endline="63">
static PyInt16 search (PyInt16 val, PyInt16 *table, int size) {
    int i;
    for (i = 0; i < size; i++) {
        if (val <= *table++)
            return (i);
    }
    return (size);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="139" endline="174">
static unsigned char st_14linear2ulaw (PyInt16 pcm_val) {
    PyInt16 mask;
    PyInt16 seg;
    unsigned char uval;
    pcm_val = pcm_val >> 2;
    if (pcm_val < 0) {
        pcm_val = -pcm_val;
        mask = 0x7F;
    }
    else {
        mask = 0xFF;
    }
    if (pcm_val > CLIP)
        pcm_val = CLIP;
    pcm_val += (BIAS >> 2);
    seg = search (pcm_val, seg_uend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);
        return (uval ^ mask);
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="236" endline="269">
static unsigned char st_linear2alaw (PyInt16 pcm_val) {
    PyInt16 mask;
    short seg;
    unsigned char aval;
    pcm_val = pcm_val >> 3;
    if (pcm_val >= 0) {
        mask = 0xD5;
    }
    else {
        mask = 0x55;
        pcm_val = -pcm_val - 1;
    }
    seg = search (pcm_val, seg_aend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        aval = (unsigned char) seg << SEG_SHIFT;
        if (seg < 2)
            aval |= (pcm_val >> 1) & QUANT_MASK;
        else
            aval |= (pcm_val >> seg) & QUANT_MASK;
        return (aval ^ mask);
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="298" endline="319">
static PyObject *audioop_getsample (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    if (!PyArg_ParseTuple (args, "s#ii:getsample", &cp, &len, &size, &i))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (i < 0 || i >= len / size) {
        PyErr_SetString (AudioopError, "Index out of range");
        return 0;
    }
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i *2);
    else if (size == 4)
        val = (int) *LONGP (cp, i *4);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="321" endline="343">
static PyObject *audioop_max (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    int max = 0;
    if (!PyArg_ParseTuple (args, "s#i:max", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val < 0)
            val = (-val);
        if (val > max)
            max = val;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="345" endline="367">
static PyObject *audioop_minmax (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    int min = 0x7fffffff, max = -0x7fffffff;
    if (!PyArg_ParseTuple (args, "s#i:minmax", &cp, &len, &size))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val > max)
            max = val;
        if (val < min)
            min = val;
    }
    return Py_BuildValue ("(ii)", min, max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="369" endline="394">
static PyObject *audioop_avg (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    double avg = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:avg", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        avg += val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) (avg / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="396" endline="421">
static PyObject *audioop_rms (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    double sum_squares = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:rms", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        sum_squares += (double) val * (double) val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) sqrt (sum_squares / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="423" endline="432">
static double _sum2 (short *a, short *b, int len) {
    int i;
    double sum = 0.0;
    for (i = 0; i < len; i++) {
        sum = sum + (double) a[i] * (double) b[i];
    }
    return sum;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="466" endline="519">
static PyObject *audioop_findfit (PyObject *self, PyObject *args) {
    short *cp1, *cp2;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double sum_ri_2, sum_aij_2, sum_aij_ri, result, best_result, factor;
    if (!PyArg_ParseTuple (args, "s#s#:findfit", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    len2 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "First sample should be longer");
        return 0;
    }
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_2 = _sum2 (cp1, cp1, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        sum_aij_2 = sum_aij_2 + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        sum_aij_ri = _sum2 (cp1 +j, cp2, len2);
        result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
        if (result < best_result) {
            best_result = result;
            best_j = j;
        }
    }
    factor = _sum2 (cp1 +best_j, cp2, len2) / sum_ri_2;
    return Py_BuildValue ("(if)", best_j, factor);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="525" endline="550">
static PyObject *audioop_findfactor (PyObject *self, PyObject *args) {
    short *cp1, *cp2;
    int len1, len2;
    double sum_ri_2, sum_aij_ri, result;
    if (!PyArg_ParseTuple (args, "s#s#:findfactor", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Samples should be same size");
        return 0;
    }
    len2 >>= 1;
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = sum_aij_ri / sum_ri_2;
    return PyFloat_FromDouble (result);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="556" endline="598">
static PyObject *audioop_findmax (PyObject *self, PyObject *args) {
    short *cp1;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double result, best_result;
    if (!PyArg_ParseTuple (args, "s#i:findmax", &cp1, &len1, &len2))
        return 0;
    if (len1 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "Input sample should be longer");
        return 0;
    }
    result = _sum2 (cp1, cp1, len2);
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        result = result + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        if (result > best_result) {
            best_result = result;
            best_j = j;
        }
    }
    return PyInt_FromLong (best_j);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="600" endline="655">
static PyObject *audioop_avgpp (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    double avg = 0.0;
    int diff, prevdiff, extremediff, nextreme = 0;
    if (!PyArg_ParseTuple (args, "s#i:avgpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                avg += extremediff;
                nextreme++;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    if (nextreme == 0)
        val = 0;
    else
        val = (int) (avg / (double) nextreme);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="657" endline="708">
static PyObject *audioop_maxpp (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    int max = 0;
    int diff, prevdiff, extremediff;
    if (!PyArg_ParseTuple (args, "s#i:maxpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                if (extremediff > max)
                    max = extremediff;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="710" endline="735">
static PyObject *audioop_cross (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    int prevval, ncross;
    if (!PyArg_ParseTuple (args, "s#i:cross", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    ncross = -1;
    prevval = 17;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) >> 7;
        else if (size == 2)
            val = ((int) *SHORTP (cp, i)) >> 15;
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 31;
        val = val & 1;
        if (val != prevval)
            ncross++;
        prevval = val;
    }
    return PyInt_FromLong (ncross);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="737" endline="776">
static PyObject *audioop_mul (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val = 0;
    double factor, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#id:mul", &cp, &len, &size, &factor))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * factor;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val = (int) fval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) val;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) val;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) val;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="778" endline="821">
static PyObject *audioop_tomono (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val1 = 0, val2 = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tomono", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / 2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size * 2) {
        if (size == 1)
            val1 = (int) *CHARP (cp, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp, i);
        if (size == 1)
            val2 = (int) *CHARP (cp, i +1);
        else if (size == 2)
            val2 = (int) *SHORTP (cp, i +2);
        else if (size == 4)
            val2 = (int) *LONGP (cp, i +4);
        fval = (double) val1 * fac1 + (double) val2 * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i / 2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i / 2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i / 2) = (Py_Int32) val1;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="823" endline="874">
static PyObject *audioop_tostereo (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val1, val2, val = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tostereo", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * fac1;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        fval = (double) val * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val2 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i *2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i *2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i *2) = (Py_Int32) val1;
        if (size == 1)
            *CHARP (ncp, i *2 + 1) = (signed char) val2;
        else if (size == 2)
            *SHORTP (ncp, i *2 + 2) = (short) val2;
        else if (size == 4)
            *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="876" endline="927">
static PyObject *audioop_add (PyObject *self, PyObject *args) {
    signed char *cp1, *cp2, *ncp;
    int len1, len2, size, val1 = 0, val2 = 0, maxval, newval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#s#i:add", &cp1, &len1, &cp2, &len2, &size))
        return 0;
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Lengths should be the same");
        return 0;
    }
    if (size == 1)
        maxval = 0x7f;
    else if (size == 2)
        maxval = 0x7fff;
    else if (size == 4)
        maxval = 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len1);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len1; i += size) {
        if (size == 1)
            val1 = (int) *CHARP (cp1, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp1, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp1, i);
        if (size == 1)
            val2 = (int) *CHARP (cp2, i);
        else if (size == 2)
            val2 = (int) *SHORTP (cp2, i);
        else if (size == 4)
            val2 = (int) *LONGP (cp2, i);
        newval = val1 + val2;
        if (newval > maxval)
            newval = maxval;
        else if (newval < -maxval)
            newval = -maxval;
        else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
            newval = val1 > 0 ? maxval : -maxval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) newval;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) newval;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) newval;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="929" endline="963">
static PyObject *audioop_bias (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    int bias;
    if (!PyArg_ParseTuple (args, "s#ii:bias", &cp, &len, &size, &bias))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val + bias);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val + bias);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val + bias);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="965" endline="1000">
static PyObject *audioop_reverse (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#i:reverse", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        j = len - i - size;
        if (size == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1002" endline="1036">
static PyObject *audioop_lin2lin (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, size2, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#ii:lin2lin", &cp, &len, &size, &size2))
        return 0;
    if ((size != 1 && size != 2 && size != 4) || (size2 != 1 && size2 != 2 && size2 != 4)) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, (len / size) * size2);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0, j = 0; i < len; i += size, j += size2) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        if (size2 == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size2 == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size2 == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1038" endline="1047">
static int gcd (int a, int b) {
    while (b > 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1049" endline="1233">
static PyObject *audioop_ratecv (PyObject *self, PyObject *args) {
    char *cp, *ncp;
    int len, size, nchannels, inrate, outrate, weightA, weightB;
    int chan, d, *prev_i, *cur_i, cur_o;
    PyObject *state, *samps, *str, *rv = NULL;
    int bytes_per_frame;
    weightA = 1;
    weightB = 0;
    if (!PyArg_ParseTuple (args, "s#iiiiO|ii:ratecv", &cp, &len, &size, &nchannels, &inrate, &outrate, &state, &weightA, &weightB))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    if (nchannels < 1) {
        PyErr_SetString (AudioopError, "# of channels should be >= 1");
        return NULL;
    }
    bytes_per_frame = size * nchannels;
    if (bytes_per_frame / nchannels != size) {
        PyErr_SetString (PyExc_OverflowError, "width * nchannels too big for a C int");
        return NULL;
    }
    if (weightA < 1 || weightB < 0) {
        PyErr_SetString (AudioopError, "weightA should be >= 1, weightB should be >= 0");
        return NULL;
    }
    if (len % bytes_per_frame != 0) {
        PyErr_SetString (AudioopError, "not a whole number of frames");
        return NULL;
    }
    if (inrate <= 0 || outrate <= 0) {
        PyErr_SetString (AudioopError, "sampling rate not > 0");
        return NULL;
    }
    d = gcd (inrate, outrate);
    inrate /= d;
    outrate /= d;
    prev_i = (int *) malloc (nchannels * sizeof (int));
    cur_i = (int *) malloc (nchannels * sizeof (int));
    if (prev_i == NULL || cur_i == NULL) {
        (void) PyErr_NoMemory ();
        goto exit;
    }
    len /= bytes_per_frame;
    if (state == Py_None) {
        d = -outrate;
        for (chan = 0; chan < nchannels; chan++)
            prev_i[chan] = cur_i[chan] = 0;
    }
    else {
        if (!PyArg_ParseTuple (state, "iO!;audioop.ratecv: illegal state argument", &d, &PyTuple_Type, &samps))
            goto exit;
        if (PyTuple_Size (samps) != nchannels) {
            PyErr_SetString (AudioopError, "illegal state argument");
            goto exit;
        }
        for (chan = 0; chan < nchannels; chan++) {
            if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
                goto exit;
        }
    }
    {
        int ceiling;
        int nbytes;
        int q = len / inrate;
        ceiling = (q + 1) * outrate;
        nbytes = ceiling * bytes_per_frame;
        if (q + 1 < 0 || ceiling / outrate != q + 1 || nbytes / bytes_per_frame != ceiling)
            str = NULL;
        else
            str = PyString_FromStringAndSize (NULL, nbytes);
        if (str == NULL) {
            PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
            goto exit;
        }
    }
    ncp = PyString_AsString (str);
    for (;;) {
        while (d < 0) {
            if (len == 0) {
                samps = PyTuple_New (nchannels);
                if (samps == NULL)
                    goto exit;
                for (chan = 0; chan < nchannels; chan++)
                    PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
                if (PyErr_Occurred ())
                    goto exit;
                len = (int) (ncp - PyString_AsString (str));
                if (len == 0) {
                    rv = PyString_FromStringAndSize ("", 0);
                    Py_DECREF (str);
                    str = rv;
                }
                else if (_PyString_Resize (&str, len) < 0)
                    goto exit;
                rv = Py_BuildValue ("(O(iO))", str, d, samps);
                Py_DECREF (samps);
                Py_DECREF (str);
                goto exit;
            }
            for (chan = 0; chan < nchannels; chan++) {
                prev_i[chan] = cur_i[chan];
                if (size == 1)
                    cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
                else if (size == 2)
                    cur_i[chan] = (int) *SHORTP (cp, 0);
                else if (size == 4)
                    cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
                cp += size;
                cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
            }
            len--;
            d += outrate;
        }
        while (d >= 0) {
            for (chan = 0; chan < nchannels; chan++) {
                cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
                if (size == 1)
                    *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
                else if (size == 2)
                    *SHORTP (ncp, 0) = (short) (cur_o);
                else if (size == 4)
                    *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
                ncp += size;
            }
            d -= inrate;
        }
    }
exit :
    if (prev_i != NULL)
        free (prev_i);
    if (cur_i != NULL)
        free (cur_i);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1235" endline="1266">
static PyObject *audioop_lin2ulaw (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2ulaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_14linear2ulaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1268" endline="1301">
static PyObject *audioop_ulaw2lin (PyObject *self, PyObject *args) {
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:ulaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_ulaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1303" endline="1334">
static PyObject *audioop_lin2alaw (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2alaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_linear2alaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1336" endline="1369">
static PyObject *audioop_alaw2lin (PyObject *self, PyObject *args) {
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:alaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_alaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1371" endline="1478">
static PyObject *audioop_lin2adpcm (PyObject *self, PyObject *args) {
    signed char *cp;
    signed char *ncp;
    int len, size, val = 0, step, valpred, delta, index, sign, vpdiff, diff;
    PyObject *rv, *state, *str;
    int i, outputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:lin2adpcm", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    str = PyString_FromStringAndSize (NULL, len / (size * 2));
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    step = stepsizeTable[index];
    bufferstep = 1;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        diff = val - valpred;
        sign = (diff < 0) ? 8 : 0;
        if (sign)
            diff = (-diff);
        delta = 0;
        vpdiff = (step >> 3);
        if (diff >= step) {
            delta = 4;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 2;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 1;
            vpdiff += step;
        }
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        delta |= sign;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        step = stepsizeTable[index];
        if (bufferstep) {
            outputbuffer = (delta << 4) & 0xf0;
        }
        else {
            *ncp++ = (delta & 0x0f) | outputbuffer;
        }
        bufferstep = !bufferstep;
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1480" endline="1568">
static PyObject *audioop_adpcm2lin (PyObject *self, PyObject *args) {
    signed char *cp;
    signed char *ncp;
    int len, size, valpred, step, delta, index, sign, vpdiff;
    PyObject *rv, *str, *state;
    int i, inputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:adpcm2lin", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    str = PyString_FromStringAndSize (NULL, len *size * 2);
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    step = stepsizeTable[index];
    bufferstep = 0;
    for (i = 0; i < len * size * 2; i += size) {
        if (bufferstep) {
            delta = inputbuffer & 0xf;
        }
        else {
            inputbuffer = *cp++;
            delta = (inputbuffer >> 4) & 0xf;
        }
        bufferstep = !bufferstep;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        sign = delta & 8;
        delta = delta & 7;
        vpdiff = step >> 3;
        if (delta & 4)
            vpdiff += step;
        if (delta & 2)
            vpdiff += step >> 1;
        if (delta & 1)
            vpdiff += step >> 2;
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        step = stepsizeTable[index];
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (valpred >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (valpred);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1599" endline="1612">
PyMODINIT_FUNC initaudioop (void) {
    PyObject *m, *d;
    m = Py_InitModule ("audioop", audioop_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (d == NULL)
        return;
    AudioopError = PyErr_NewException ("audioop.error", NULL, NULL);
    if (AudioopError != NULL)
        PyDict_SetItemString (d, "error", AudioopError);
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="26" endline="31">
static Py_complex c_acos (Py_complex x) {
    return c_neg (c_prodi (c_log (c_sum (x, c_prod (c_i, c_sqrt (c_diff (c_one, c_prod (x, x))))))));
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="39" endline="47">
static Py_complex c_acosh (Py_complex x) {
    Py_complex z;
    z = c_sqrt (c_half);
    z = c_log (c_prod (z, c_sum (c_sqrt (c_sum (x, c_one)), c_sqrt (c_diff (x, c_one)))));
    return c_sum (z, z);
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="55" endline="64">
static Py_complex c_asin (Py_complex x) {
    const Py_complex squared = c_prod (x, x);
    const Py_complex sqrt_1_minus_x_sq = c_sqrt (c_diff (c_one, squared));
    return c_neg (c_prodi (c_log (c_sum (sqrt_1_minus_x_sq, c_prodi (x)))));
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="72" endline="80">
static Py_complex c_asinh (Py_complex x) {
    Py_complex z;
    z = c_sqrt (c_half);
    z = c_log (c_prod (z, c_sum (c_sqrt (c_sum (x, c_i)), c_sqrt (c_diff (x, c_i)))));
    return c_sum (z, z);
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="88" endline="92">
static Py_complex c_atan (Py_complex x) {
    return c_prod (c_halfi, c_log (c_quot (c_sum (c_i, x), c_diff (c_i, x))));
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="100" endline="104">
static Py_complex c_atanh (Py_complex x) {
    return c_prod (c_half, c_log (c_quot (c_sum (c_one, x), c_diff (c_one, x))));
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="112" endline="119">
static Py_complex c_cos (Py_complex x) {
    Py_complex r;
    r.real = cos (x.real) * cosh (x.imag);
    r.imag = -sin (x.real) * sinh (x.imag);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="127" endline="134">
static Py_complex c_cosh (Py_complex x) {
    Py_complex r;
    r.real = cos (x.imag) * cosh (x.real);
    r.imag = sin (x.imag) * sinh (x.real);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="142" endline="150">
static Py_complex c_exp (Py_complex x) {
    Py_complex r;
    double l = exp (x.real);
    r.real = l * cos (x.imag);
    r.imag = l * sin (x.imag);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="158" endline="166">
static Py_complex c_log (Py_complex x) {
    Py_complex r;
    double l = hypot (x.real, x.imag);
    r.imag = atan2 (x.imag, x.real);
    r.real = log (l);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="169" endline="177">
static Py_complex c_log10 (Py_complex x) {
    Py_complex r;
    double l = hypot (x.real, x.imag);
    r.imag = atan2 (x.imag, x.real) / log (10.);
    r.real = log10 (l);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="186" endline="193">
static Py_complex c_prodi (Py_complex x) {
    Py_complex r;
    r.real = -x.imag;
    r.imag = x.real;
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="196" endline="203">
static Py_complex c_sin (Py_complex x) {
    Py_complex r;
    r.real = sin (x.real) * cosh (x.imag);
    r.imag = cos (x.real) * sinh (x.imag);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="211" endline="218">
static Py_complex c_sinh (Py_complex x) {
    Py_complex r;
    r.real = cos (x.imag) * sinh (x.real);
    r.imag = sin (x.imag) * cosh (x.real);
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="226" endline="250">
static Py_complex c_sqrt (Py_complex x) {
    Py_complex r;
    double s, d;
    if (x.real == 0.&& x.imag == 0.)
        r = x;
    else {
        s = sqrt (0.5 * (fabs (x.real) + hypot (x.real, x.imag)));
        d = 0.5 * x.imag / s;
        if (x.real > 0.) {
            r.real = s;
            r.imag = d;
        }
        else if (x.imag >= 0.) {
            r.real = d;
            r.imag = s;
        }
        else {
            r.real = -d;
            r.imag = -s;
        }
    }
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="258" endline="277">
static Py_complex c_tan (Py_complex x) {
    Py_complex r;
    double sr, cr, shi, chi;
    double rs, is, rc, ic;
    double d;
    sr = sin (x.real);
    cr = cos (x.real);
    shi = sinh (x.imag);
    chi = cosh (x.imag);
    rs = sr * chi;
    is = cr * shi;
    rc = cr * chi;
    ic = -sr * shi;
    d = rc * rc + ic * ic;
    r.real = (rs * rc + is * ic) / d;
    r.imag = (is * rc - rs * ic) / d;
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="285" endline="304">
static Py_complex c_tanh (Py_complex x) {
    Py_complex r;
    double si, ci, shr, chr;
    double rs, is, rc, ic;
    double d;
    si = sin (x.imag);
    ci = cos (x.imag);
    shr = sinh (x.real);
    chr = cosh (x.real);
    rs = ci * shr;
    is = si * chr;
    rc = ci * chr;
    ic = si * shr;
    d = rc * rc + ic * ic;
    r.real = (rs * rc + is * ic) / d;
    r.imag = (is * rc - rs * ic) / d;
    return r;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="311" endline="330">
static PyObject *cmath_log (PyObject *self, PyObject *args) {
    Py_complex x;
    Py_complex y;
    if (!PyArg_ParseTuple (args, "D|D", &x, &y))
        return NULL;
    errno = 0;
    PyFPE_START_PROTECT ("complex function", return 0)
    x = c_log (x);
    if (PyTuple_GET_SIZE (args) == 2)
        x = c_quot (x, c_log (y));
    PyFPE_END_PROTECT (x)
    if (errno != 0)
        return math_error ();
    Py_ADJUST_ERANGE2 (x.real, x.imag);
    return PyComplex_FromCComplex (x);
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="339" endline="349">
static PyObject *math_error (void) {
    if (errno == EDOM)
        PyErr_SetString (PyExc_ValueError, "math domain error");
    else if (errno == ERANGE)
        PyErr_SetString (PyExc_OverflowError, "math range error");
    else
        PyErr_SetFromErrno (PyExc_ValueError);
    return NULL;
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="351" endline="366">
static PyObject *math_1 (PyObject *args, Py_complex (*func) (Py_complex)) {
    Py_complex x;
    if (!PyArg_ParseTuple (args, "D", &x))
        return NULL;
    errno = 0;
    PyFPE_START_PROTECT ("complex function", return 0)
    x = (*func) (x);
    PyFPE_END_PROTECT (x) Py_ADJUST_ERANGE2 (x.real, x.imag);
    if (errno != 0)
        return math_error ();
    else
        return PyComplex_FromCComplex (x);
}
</source>
<source file="examples2/python//cmathmodule.c.ifdefed" startline="414" endline="426">
PyMODINIT_FUNC initcmath (void) {
    PyObject *m;
    m = Py_InitModule3 ("cmath", cmath_methods, module_doc);
    if (m == NULL)
        return;
    PyModule_AddObject (m, "pi", PyFloat_FromDouble (atan (1.0) * 4.0));
    PyModule_AddObject (m, "e", PyFloat_FromDouble (exp (1.0)));
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="18" endline="27">
static int conv_descriptor (PyObject *object, int *target) {
    int fd = PyObject_AsFileDescriptor (object);
    if (fd < 0)
        return 0;
    *target = fd;
    return 1;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="32" endline="77">
static PyObject *fcntl_fcntl (PyObject *self, PyObject *args) {
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    char buf [1024];
    if (PyArg_ParseTuple (args, "O&is#:fcntl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > sizeof buf) {
            PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&i|i;fcntl requires a file or file descriptor," " an integer and optionally a third integer or a string", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="95" endline="203">
static PyObject *fcntl_ioctl (PyObject *self, PyObject *args) {
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    int mutate_arg = 1;
    char buf [IOCTL_BUFSZ + 1];
    if (PyArg_ParseTuple (args, "O&Iw#|i:ioctl", conv_descriptor, &fd, &code, &str, &len, &mutate_arg)) {
        char *arg;
        if (mutate_arg) {
            if (len <= IOCTL_BUFSZ) {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
            else {
                arg = str;
            }
        }
        else {
            if (len > IOCTL_BUFSZ) {
                PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
                return NULL;
            }
            else {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
        }
        if (buf == arg) {
            Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
            Py_END_ALLOW_THREADS
        }
        else {
            ret = ioctl (fd, code, arg);
        }
        if (mutate_arg && (len < IOCTL_BUFSZ)) {
            memcpy (str, buf, len);
        }
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        if (mutate_arg) {
            return PyInt_FromLong (ret);
        }
        else {
            return PyString_FromStringAndSize (buf, len);
        }
    }
    PyErr_Clear ();
    if (PyArg_ParseTuple (args, "O&Is#:ioctl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > IOCTL_BUFSZ) {
            PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        buf[len] = '\0';
        Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&I|i;ioctl requires a file or file descriptor," " an integer and optionally an integer or buffer argument", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="239" endline="287">
static PyObject *fcntl_flock (PyObject *self, PyObject *args) {
    int fd;
    int code;
    int ret;
    if (!PyArg_ParseTuple (args, "O&i:flock", conv_descriptor, &fd, &code))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
            return NULL;
        }
        l.l_whence = l.l_start = l.l_len = 0;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="298" endline="368">
static PyObject *fcntl_lockf (PyObject *self, PyObject *args) {
    int fd, code, ret, whence = 0;
    PyObject *lenobj = NULL, *startobj = NULL;
    if (!PyArg_ParseTuple (args, "O&i|OOi:lockf", conv_descriptor, &fd, &code, &lenobj, &startobj, &whence))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
            return NULL;
        }
        l.l_start = l.l_len = 0;
        if (startobj != NULL) {
            l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        if (lenobj != NULL) {
            l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        l.l_whence = whence;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="414" endline="423">
static int ins (PyObject *d, char *symbol, long value) {
    PyObject *v = PyInt_FromLong (value);
    if (!v || PyDict_SetItemString (d, symbol, v) < 0)
        return -1;
    Py_DECREF (v);
    return 0;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="427" endline="588">
static int all_ins (PyObject *d) {
    if (ins (d, "LOCK_SH", (long) LOCK_SH))
        return -1;
    if (ins (d, "LOCK_EX", (long) LOCK_EX))
        return -1;
    if (ins (d, "LOCK_NB", (long) LOCK_NB))
        return -1;
    if (ins (d, "LOCK_UN", (long) LOCK_UN))
        return -1;
    return 0;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="590" endline="603">
PyMODINIT_FUNC initfcntl (void) {
    PyObject *m, *d;
    m = Py_InitModule3 ("fcntl", fcntl_methods, module_doc);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    all_ins (d);
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="103" endline="110">
static PyObject *turnon_sigfpe (PyObject *self, PyObject *args) {
    fpe_reset (sigfpe_handler);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="112" endline="257">
static void fpe_reset (Sigfunc *handler) {
    fputs ("Operation not implemented\n", stderr);
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="259" endline="277">
static PyObject *turnoff_sigfpe (PyObject *self, PyObject *args) {
    fputs ("Operation not implemented\n", stderr);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="279" endline="287">
static void sigfpe_handler (int signo) {
    fpe_reset (sigfpe_handler);
    if (PyFPE_counter) {
        longjmp (PyFPE_jbuf, 1);
    }
    else {
        Py_FatalError ("Unprotected floating point exception");
    }
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="289" endline="299">
PyMODINIT_FUNC initfpectl (void) {
    PyObject *m, *d;
    m = Py_InitModule ("fpectl", fpectl_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpectl.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="61" endline="99">
static PyObject *test (PyObject *self, PyObject *args) {
    double r;
    fprintf (stderr, "overflow");
    r = overflow (1.e160);
    printerr (r);
    fprintf (stderr, "\ndiv by 0");
    r = db0 (0.0);
    printerr (r);
    fprintf (stderr, "\nnested outer");
    r = nest1 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested inner");
    r = nest1 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\ntrailing outer");
    r = nest1 (2, 2.0);
    printerr (r);
    fprintf (stderr, "\nnested prior");
    r = nest2 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested interior");
    r = nest2 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\nnested trailing");
    r = nest2 (2, 2.0);
    printerr (r);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="101" endline="110">
static void printerr (double r) {
    if (r == 3.1416) {
        fprintf (stderr, "\tPASS\n");
        PyErr_Print ();
    }
    else {
        fprintf (stderr, "\tFAIL\n");
    }
    PyErr_Clear ();
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="112" endline="130">
static double nest1 (int i, double x) {
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, outer zone", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        PyFPE_START_PROTECT ("Division by zero, inner zone", return 3.1416)
        a = 1./ (1.- x);
        PyFPE_END_PROTECT (a)
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="132" endline="145">
static double nest2 (int i, double x) {
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, prior error", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        a = nest3 (x);
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="147" endline="155">
static double nest3 (double x) {
    double result;
    PyFPE_START_PROTECT ("Division by zero, nest3 error", return 3.1416)
    result = 1./ (1.- x);
    PyFPE_END_PROTECT (result)
    return result;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="157" endline="164">
static double db0 (double x) {
    double a;
    PyFPE_START_PROTECT ("Division by zero", return 3.1416)
    a = 1./ x;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="166" endline="173">
static double overflow (double b) {
    double a;
    PyFPE_START_PROTECT ("Overflow", return 3.1416)
    a = b * b;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="175" endline="186">
PyMODINIT_FUNC initfpetest (void) {
    PyObject *m, *d;
    m = Py_InitModule ("fpetest", fpetest_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpetest.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="35" endline="84">
static PyObject *mkgrent (struct group *p) {
    int setIndex = 0;
    PyObject *v = PyStructSequence_New (&StructGrpType), *w;
    char **member;
    if (v == NULL)
        return NULL;
    if ((w = PyList_New (0)) == NULL) {
        Py_DECREF (v);
        return NULL;
    }
    for (member = p->gr_mem; *member != NULL; member++) {
        PyObject *x = PyString_FromString (*member);
        if (x == NULL || PyList_Append (w, x) != 0) {
            Py_XDECREF (x);
            Py_DECREF (w);
            Py_DECREF (v);
            return NULL;
        }
        Py_DECREF (x);
    }
    SET (setIndex ++, PyString_FromString (p -> gr_name));
    if (p->gr_passwd)
        SET (setIndex++, PyString_FromString (p->gr_passwd));
    else {
        SET (setIndex ++, Py_None);
        Py_INCREF (Py_None);
    }
    SET (setIndex ++, PyInt_FromLong ((long) p -> gr_gid));
    SET (setIndex ++, w);
    if (PyErr_Occurred ()) {
        Py_DECREF (v);
        Py_DECREF (w);
        return NULL;
    }
    return v;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="86" endline="104">
static PyObject *grp_getgrgid (PyObject *self, PyObject *pyo_id) {
    PyObject *py_int_id;
    unsigned int gid;
    struct group *p;
    py_int_id = PyNumber_Int (pyo_id);
    if (!py_int_id)
        return NULL;
    gid = PyInt_AS_LONG (py_int_id);
    Py_DECREF (py_int_id);
    if ((p = getgrgid (gid)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
        return NULL;
    }
    return mkgrent (p);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="106" endline="126">
static PyObject *grp_getgrnam (PyObject *self, PyObject *pyo_name) {
    PyObject *py_str_name;
    char *name;
    struct group *p;
    py_str_name = PyObject_Str (pyo_name);
    if (!py_str_name)
        return NULL;
    name = PyString_AS_STRING (py_str_name);
    if ((p = getgrnam (name)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
        Py_DECREF (py_str_name);
        return NULL;
    }
    Py_DECREF (py_str_name);
    return mkgrent (p);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="128" endline="148">
static PyObject *grp_getgrall (PyObject *self, PyObject *ignore) {
    PyObject *d;
    struct group *p;
    if ((d = PyList_New (0)) == NULL)
        return NULL;
    setgrent ();
    while ((p = getgrent ()) != NULL) {
        PyObject *v = mkgrent (p);
        if (v == NULL || PyList_Append (d, v) != 0) {
            Py_XDECREF (v);
            Py_DECREF (d);
            return NULL;
        }
        Py_DECREF (v);
    }
    endgrent ();
    return d;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="182" endline="194">
PyMODINIT_FUNC initgrp (void) {
    PyObject *m, *d;
    m = Py_InitModule3 ("grp", grp_methods, grp__doc__);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (!initialized)
        PyStructSequence_InitType (&StructGrpType, &struct_group_type_desc);
    PyDict_SetItemString (d, "struct_group", (PyObject *) & StructGrpType);
    initialized = 1;
}
</source>
