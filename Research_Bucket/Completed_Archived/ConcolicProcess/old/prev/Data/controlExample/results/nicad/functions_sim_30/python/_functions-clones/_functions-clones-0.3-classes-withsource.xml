<clones>
<systeminfo processor="nicad3" system="_" granularity="unctions" threshold="30%" minlines="3" maxlines="2500"/>
<cloneinfo npcs="78" npairs="6"/>
<runinfo ncompares="699" cputime="5"/>
<classinfo nclasses="6"/>

<class classid="1" nclones="2" nlines="54" similarity="79">
<source file="examples2/python//audioop.c.ifdefed" startline="600" endline="655" pcid="13">
static PyObject *
audioop_avgpp(PyObject *self, PyObject *args)
{
        signed char *cp;
        int len, size, val = 0, prevval = 0, prevextremevalid = 0,
                prevextreme = 0;
        int i;
        double avg = 0.0;
        int diff, prevdiff, extremediff, nextreme = 0;

        if ( !PyArg_ParseTuple(args, "s#i:avgpp", &cp, &len, &size) )
                return 0;
        if ( size != 1 && size != 2 && size != 4 ) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
        /* Compute first delta value ahead. Also automatically makes us
        ** skip the first extreme value
        */
        if ( size == 1 )      prevval = (int)*CHARP(cp, 0);
        else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);
        else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);
        if ( size == 1 )      val = (int)*CHARP(cp, size);
        else if ( size == 2 ) val = (int)*SHORTP(cp, size);
        else if ( size == 4 ) val = (int)*LONGP(cp, size);
        prevdiff = val - prevval;
    
        for ( i=size; i<len; i+= size) {
                if ( size == 1 )      val = (int)*CHARP(cp, i);
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = (int)*LONGP(cp, i);
                diff = val - prevval;
                if ( diff*prevdiff < 0 ) {
                        /* Derivative changed sign. Compute difference to last
                        ** extreme value and remember.
                        */
                        if ( prevextremevalid ) {
                                extremediff = prevval - prevextreme;
                                if ( extremediff < 0 )
                                        extremediff = -extremediff;
                                avg += extremediff;
                                nextreme++;
                        }
                        prevextremevalid = 1;
                        prevextreme = prevval;
                }
                prevval = val;
                if ( diff != 0 )
                        prevdiff = diff;        
        }
        if ( nextreme == 0 )
                val = 0;
        else
                val = (int)(avg / (double)nextreme);
        return PyInt_FromLong(val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="657" endline="708" pcid="14">
static PyObject *
audioop_maxpp(PyObject *self, PyObject *args)
{
        signed char *cp;
        int len, size, val = 0, prevval = 0, prevextremevalid = 0,
                prevextreme = 0;
        int i;
        int max = 0;
        int diff, prevdiff, extremediff;

        if ( !PyArg_ParseTuple(args, "s#i:maxpp", &cp, &len, &size) )
                return 0;
        if ( size != 1 && size != 2 && size != 4 ) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
        /* Compute first delta value ahead. Also automatically makes us
        ** skip the first extreme value
        */
        if ( size == 1 )      prevval = (int)*CHARP(cp, 0);
        else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);
        else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);
        if ( size == 1 )      val = (int)*CHARP(cp, size);
        else if ( size == 2 ) val = (int)*SHORTP(cp, size);
        else if ( size == 4 ) val = (int)*LONGP(cp, size);
        prevdiff = val - prevval;

        for ( i=size; i<len; i+= size) {
                if ( size == 1 )      val = (int)*CHARP(cp, i);
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = (int)*LONGP(cp, i);
                diff = val - prevval;
                if ( diff*prevdiff < 0 ) {
                        /* Derivative changed sign. Compute difference to
                        ** last extreme value and remember.
                        */
                        if ( prevextremevalid ) {
                                extremediff = prevval - prevextreme;
                                if ( extremediff < 0 )
                                        extremediff = -extremediff;
                                if ( extremediff > max )
                                        max = extremediff;
                        }
                        prevextremevalid = 1;
                        prevextreme = prevval;
                }
                prevval = val;
                if ( diff != 0 )
                        prevdiff = diff;
        }
        return PyInt_FromLong(max);
}
</source>
</class>

<class classid="2" nclones="2" nlines="29" similarity="89">
<source file="examples2/python//audioop.c.ifdefed" startline="1268" endline="1301" pcid="26">
static PyObject *
audioop_ulaw2lin(PyObject *self, PyObject *args)
{
        unsigned char *cp;
        unsigned char cval;
        signed char *ncp;
        int len, size, val;
        PyObject *rv;
        int i;

        if ( !PyArg_ParseTuple(args, "s#i:ulaw2lin",
                               &cp, &len, &size) )
                return 0;

        if ( size != 1 && size != 2 && size != 4) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
    
        rv = PyString_FromStringAndSize(NULL, len*size);
        if ( rv == 0 )
                return 0;
        ncp = (signed char *)PyString_AsString(rv);
    
        for ( i=0; i < len*size; i += size ) {
                cval = *cp++;
                val = st_ulaw2linear16(cval);
        
                if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);
                else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);
                else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);
        }
        return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1336" endline="1369" pcid="28">
static PyObject *
audioop_alaw2lin(PyObject *self, PyObject *args)
{
        unsigned char *cp;
        unsigned char cval;
        signed char *ncp;
        int len, size, val;
        PyObject *rv;
        int i;

        if ( !PyArg_ParseTuple(args, "s#i:alaw2lin",
                               &cp, &len, &size) )
                return 0;

        if ( size != 1 && size != 2 && size != 4) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
    
        rv = PyString_FromStringAndSize(NULL, len*size);
        if ( rv == 0 )
                return 0;
        ncp = (signed char *)PyString_AsString(rv);
    
        for ( i=0; i < len*size; i += size ) {
                cval = *cp++;
                val = st_alaw2linear16(cval);
        
                if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);
                else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);
                else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);
        }
        return rv;
}
</source>
</class>

<class classid="3" nclones="2" nlines="27" similarity="88">
<source file="examples2/python//audioop.c.ifdefed" startline="1303" endline="1334" pcid="27">
static PyObject *
audioop_lin2alaw(PyObject *self, PyObject *args)
{
        signed char *cp;
        unsigned char *ncp;
        int len, size, val = 0;
        PyObject *rv;
        int i;

        if ( !PyArg_ParseTuple(args, "s#i:lin2alaw",
                               &cp, &len, &size) )
                return 0;

        if ( size != 1 && size != 2 && size != 4) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
    
        rv = PyString_FromStringAndSize(NULL, len/size);
        if ( rv == 0 )
                return 0;
        ncp = (unsigned char *)PyString_AsString(rv);
    
        for ( i=0; i < len; i += size ) {
                if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

                *ncp++ = st_linear2alaw(val);
        }
        return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1235" endline="1266" pcid="25">
static PyObject *
audioop_lin2ulaw(PyObject *self, PyObject *args)
{
        signed char *cp;
        unsigned char *ncp;
        int len, size, val = 0;
        PyObject *rv;
        int i;

        if ( !PyArg_ParseTuple(args, "s#i:lin2ulaw",
                               &cp, &len, &size) )
                return 0 ;

        if ( size != 1 && size != 2 && size != 4) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
    
        rv = PyString_FromStringAndSize(NULL, len/size);
        if ( rv == 0 )
                return 0;
        ncp = (unsigned char *)PyString_AsString(rv);
    
        for ( i=0; i < len; i += size ) {
                if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

                *ncp++ = st_14linear2ulaw(val);
        }
        return rv;
}
</source>
</class>

<class classid="4" nclones="2" nlines="26" similarity="80">
<source file="examples2/python//audioop.c.ifdefed" startline="369" endline="394" pcid="7">
static PyObject *
audioop_avg(PyObject *self, PyObject *args)
{
        signed char *cp;
        int len, size, val = 0;
        int i;
        double avg = 0.0;

        if ( !PyArg_ParseTuple(args, "s#i:avg", &cp, &len, &size) )
                return 0;
        if ( size != 1 && size != 2 && size != 4 ) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
        for ( i=0; i<len; i+= size) {
                if ( size == 1 )      val = (int)*CHARP(cp, i);
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = (int)*LONGP(cp, i);
                avg += val;
        }
        if ( len == 0 )
                val = 0;
        else
                val = (int)(avg / (double)(len/size));
        return PyInt_FromLong(val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="396" endline="421" pcid="8">
static PyObject *
audioop_rms(PyObject *self, PyObject *args)
{
        signed char *cp;
        int len, size, val = 0;
        int i;
        double sum_squares = 0.0;

        if ( !PyArg_ParseTuple(args, "s#i:rms", &cp, &len, &size) )
                return 0;
        if ( size != 1 && size != 2 && size != 4 ) {
                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
                return 0;
        }
        for ( i=0; i<len; i+= size) {
                if ( size == 1 )      val = (int)*CHARP(cp, i);
                else if ( size == 2 ) val = (int)*SHORTP(cp, i);
                else if ( size == 4 ) val = (int)*LONGP(cp, i);
                sum_squares += (double)val*(double)val;
        }
        if ( len == 0 )
                val = 0;
        else
                val = (int)sqrt(sum_squares / (double)(len/size));
        return PyInt_FromLong(val);
}
</source>
</class>

<class classid="5" nclones="2" nlines="17" similarity="70">
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="112" endline="130" pcid="68">
static double nest1(int i, double x)
{
  double a = 1.0;

  PyFPE_START_PROTECT("Division by zero, outer zone", return 3.1416)
  if(i == 0){
    a = 1./x;
  }else if(i == 1){
    /* This (following) message is never seen. */
    PyFPE_START_PROTECT("Division by zero, inner zone", return 3.1416)
    a = 1./(1. - x);
    PyFPE_END_PROTECT(a)
  }else if(i == 2){
    a = 1./(2. - x);
  }
  PyFPE_END_PROTECT(a)

  return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="132" endline="145" pcid="69">
static double nest2(int i, double x)
{
  double a = 1.0;
  PyFPE_START_PROTECT("Division by zero, prior error", return 3.1416)
  if(i == 0){
    a = 1./x;
  }else if(i == 1){
    a = nest3(x);
  }else if(i == 2){
    a = 1./(2. - x);
  }
  PyFPE_END_PROTECT(a)
  return a;
}
</source>
</class>

<class classid="6" nclones="2" nlines="10" similarity="70">
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="289" endline="299" pcid="65">
PyMODINIT_FUNC initfpectl(void)
{
    PyObject *m, *d;
    m = Py_InitModule("fpectl", fpectl_methods);
    if (m == NULL)
    	return;
    d = PyModule_GetDict(m);
    fpe_error = PyErr_NewException("fpectl.error", NULL, NULL);
    if (fpe_error != NULL)
	PyDict_SetItemString(d, "error", fpe_error);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="175" endline="186" pcid="73">
PyMODINIT_FUNC initfpetest(void)
{
    PyObject *m, *d;

    m = Py_InitModule("fpetest", fpetest_methods);
    if (m == NULL)
    	return;
    d = PyModule_GetDict(m);
    fpe_error = PyErr_NewException("fpetest.error", NULL, NULL);
    if (fpe_error != NULL)
	    PyDict_SetItemString(d, "error", fpe_error);
}
</source>
</class>

</clones>
