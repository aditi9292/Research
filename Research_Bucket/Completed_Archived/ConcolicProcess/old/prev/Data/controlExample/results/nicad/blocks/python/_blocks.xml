<source file="examples2/python//audioop.c.ifdefed" startline="55" endline="63">
{
    int i;
    for (i = 0; i < size; i++) {
        if (val <= *table++)
            return (i);
    }
    return (size);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="58" endline="61">
{
    if (val <= *table++)
        return (i);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="141" endline="174">
{
    PyInt16 mask;
    PyInt16 seg;
    unsigned char uval;
    pcm_val = pcm_val >> 2;
    if (pcm_val < 0) {
        pcm_val = -pcm_val;
        mask = 0x7F;
    }
    else {
        mask = 0xFF;
    }
    if (pcm_val > CLIP)
        pcm_val = CLIP;
    pcm_val += (BIAS >> 2);
    seg = search (pcm_val, seg_uend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);
        return (uval ^ mask);
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="151" endline="154">
{
    pcm_val = -pcm_val;
    mask = 0x7F;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="154" endline="156">
{
    mask = 0xFF;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="169" endline="172">
{
    uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);
    return (uval ^ mask);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="238" endline="269">
{
    PyInt16 mask;
    short seg;
    unsigned char aval;
    pcm_val = pcm_val >> 3;
    if (pcm_val >= 0) {
        mask = 0xD5;
    }
    else {
        mask = 0x55;
        pcm_val = -pcm_val - 1;
    }
    seg = search (pcm_val, seg_aend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        aval = (unsigned char) seg << SEG_SHIFT;
        if (seg < 2)
            aval |= (pcm_val >> 1) & QUANT_MASK;
        else
            aval |= (pcm_val >> seg) & QUANT_MASK;
        return (aval ^ mask);
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="247" endline="249">
{
    mask = 0xD5;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="249" endline="252">
{
    mask = 0x55;
    pcm_val = -pcm_val - 1;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="261" endline="268">
{
    aval = (unsigned char) seg << SEG_SHIFT;
    if (seg < 2)
        aval |= (pcm_val >> 1) & QUANT_MASK;
    else
        aval |= (pcm_val >> seg) & QUANT_MASK;
    return (aval ^ mask);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="300" endline="319">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    if (!PyArg_ParseTuple (args, "s#ii:getsample", &cp, &len, &size, &i))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (i < 0 || i >= len / size) {
        PyErr_SetString (AudioopError, "Index out of range");
        return 0;
    }
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i *2);
    else if (size == 4)
        val = (int) *LONGP (cp, i *4);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="307" endline="310">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="311" endline="314">
{
    PyErr_SetString (AudioopError, "Index out of range");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="323" endline="343">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int max = 0;
    if (!PyArg_ParseTuple (args, "s#i:max", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val < 0)
            val = (-val);
        if (val > max)
            max = val;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="331" endline="334">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="335" endline="341">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (val < 0)
        val = (-val);
    if (val > max)
        max = val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="347" endline="367">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int min = 0x7fffffff, max = -0x7fffffff;
    if (!PyArg_ParseTuple (args, "s#i:minmax", &cp, &len, &size))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val > max)
            max = val;
        if (val < min)
            min = val;
    }
    return Py_BuildValue ("(ii)", min, max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="355" endline="358">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="359" endline="365">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (val > max)
        max = val;
    if (val < min)
        min = val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="371" endline="394">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    double avg = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:avg", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        avg += val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) (avg / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="379" endline="382">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="383" endline="388">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    avg += val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="398" endline="421">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    double sum_squares = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:rms", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        sum_squares += (double) val * (double) val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) sqrt (sum_squares / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="406" endline="409">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="410" endline="415">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    sum_squares += (double) val * (double) val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="424" endline="432">
{
    int i;
    double sum = 0.0;
    for (i = 0; i < len; i++) {
        sum = sum + (double) a[i] * (double) b[i];
    }
    return sum;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="428" endline="430">
{
    sum = sum + (double) a[i] * (double) b[i];
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="468" endline="519">
{
    short *cp1, *cp2;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double sum_ri_2, sum_aij_2, sum_aij_ri, result, best_result, factor;
    if (!PyArg_ParseTuple (args, "s#s#:findfit", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    len2 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "First sample should be longer");
        return 0;
    }
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_2 = _sum2 (cp1, cp1, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        sum_aij_2 = sum_aij_2 + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        sum_aij_ri = _sum2 (cp1 +j, cp2, len2);
        result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
        if (result < best_result) {
            best_result = result;
            best_j = j;
        }
    }
    factor = _sum2 (cp1 +best_j, cp2, len2) / sum_ri_2;
    return Py_BuildValue ("(if)", best_j, factor);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="478" endline="481">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="485" endline="488">
{
    PyErr_SetString (AudioopError, "First sample should be longer");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="499" endline="514">
{
    aj_m1 = (double) cp1[j - 1];
    aj_lm1 = (double) cp1[j + len2 - 1];
    sum_aij_2 = sum_aij_2 + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
    sum_aij_ri = _sum2 (cp1 +j, cp2, len2);
    result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
    if (result < best_result) {
        best_result = result;
        best_j = j;
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="509" endline="512">
{
    best_result = result;
    best_j = j;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="527" endline="550">
{
    short *cp1, *cp2;
    int len1, len2;
    double sum_ri_2, sum_aij_ri, result;
    if (!PyArg_ParseTuple (args, "s#s#:findfactor", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Samples should be same size");
        return 0;
    }
    len2 >>= 1;
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = sum_aij_ri / sum_ri_2;
    return PyFloat_FromDouble (result);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="535" endline="538">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="539" endline="542">
{
    PyErr_SetString (AudioopError, "Samples should be same size");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="558" endline="598">
{
    short *cp1;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double result, best_result;
    if (!PyArg_ParseTuple (args, "s#i:findmax", &cp1, &len1, &len2))
        return 0;
    if (len1 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "Input sample should be longer");
        return 0;
    }
    result = _sum2 (cp1, cp1, len2);
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        result = result + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        if (result > best_result) {
            best_result = result;
            best_j = j;
        }
    }
    return PyInt_FromLong (best_j);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="567" endline="570">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="573" endline="576">
{
    PyErr_SetString (AudioopError, "Input sample should be longer");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="584" endline="595">
{
    aj_m1 = (double) cp1[j - 1];
    aj_lm1 = (double) cp1[j + len2 - 1];
    result = result + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
    if (result > best_result) {
        best_result = result;
        best_j = j;
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="590" endline="593">
{
    best_result = result;
    best_j = j;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="602" endline="655">
{
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    double avg = 0.0;
    int diff, prevdiff, extremediff, nextreme = 0;
    if (!PyArg_ParseTuple (args, "s#i:avgpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                avg += extremediff;
                nextreme++;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    if (nextreme == 0)
        val = 0;
    else
        val = (int) (avg / (double) nextreme);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="612" endline="615">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="627" endline="649">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    diff = val - prevval;
    if (diff * prevdiff < 0) {
        if (prevextremevalid) {
            extremediff = prevval - prevextreme;
            if (extremediff < 0)
                extremediff = -extremediff;
            avg += extremediff;
            nextreme++;
        }
        prevextremevalid = 1;
        prevextreme = prevval;
    }
    prevval = val;
    if (diff != 0)
        prevdiff = diff;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="632" endline="645">
{
    if (prevextremevalid) {
        extremediff = prevval - prevextreme;
        if (extremediff < 0)
            extremediff = -extremediff;
        avg += extremediff;
        nextreme++;
    }
    prevextremevalid = 1;
    prevextreme = prevval;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="636" endline="642">
{
    extremediff = prevval - prevextreme;
    if (extremediff < 0)
        extremediff = -extremediff;
    avg += extremediff;
    nextreme++;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="659" endline="708">
{
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    int max = 0;
    int diff, prevdiff, extremediff;
    if (!PyArg_ParseTuple (args, "s#i:maxpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                if (extremediff > max)
                    max = extremediff;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="669" endline="672">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="684" endline="706">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    diff = val - prevval;
    if (diff * prevdiff < 0) {
        if (prevextremevalid) {
            extremediff = prevval - prevextreme;
            if (extremediff < 0)
                extremediff = -extremediff;
            if (extremediff > max)
                max = extremediff;
        }
        prevextremevalid = 1;
        prevextreme = prevval;
    }
    prevval = val;
    if (diff != 0)
        prevdiff = diff;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="689" endline="702">
{
    if (prevextremevalid) {
        extremediff = prevval - prevextreme;
        if (extremediff < 0)
            extremediff = -extremediff;
        if (extremediff > max)
            max = extremediff;
    }
    prevextremevalid = 1;
    prevextreme = prevval;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="693" endline="699">
{
    extremediff = prevval - prevextreme;
    if (extremediff < 0)
        extremediff = -extremediff;
    if (extremediff > max)
        max = extremediff;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="712" endline="735">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int prevval, ncross;
    if (!PyArg_ParseTuple (args, "s#i:cross", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    ncross = -1;
    prevval = 17;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) >> 7;
        else if (size == 2)
            val = ((int) *SHORTP (cp, i)) >> 15;
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 31;
        val = val & 1;
        if (val != prevval)
            ncross++;
        prevval = val;
    }
    return PyInt_FromLong (ncross);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="720" endline="723">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="726" endline="733">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) >> 7;
    else if (size == 2)
        val = ((int) *SHORTP (cp, i)) >> 15;
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 31;
    val = val & 1;
    if (val != prevval)
        ncross++;
    prevval = val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="739" endline="776">
{
    signed char *cp, *ncp;
    int len, size, val = 0;
    double factor, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#id:mul", &cp, &len, &size, &factor))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * factor;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val = (int) fval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) val;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) val;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) val;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="752" endline="755">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="763" endline="774">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    fval = (double) val * factor;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val = (int) fval;
    if (size == 1)
        *CHARP (ncp, i) = (signed char) val;
    else if (size == 2)
        *SHORTP (ncp, i) = (short) val;
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) val;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="780" endline="821">
{
    signed char *cp, *ncp;
    int len, size, val1 = 0, val2 = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tomono", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / 2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size * 2) {
        if (size == 1)
            val1 = (int) *CHARP (cp, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp, i);
        if (size == 1)
            val2 = (int) *CHARP (cp, i +1);
        else if (size == 2)
            val2 = (int) *SHORTP (cp, i +2);
        else if (size == 4)
            val2 = (int) *LONGP (cp, i +4);
        fval = (double) val1 * fac1 + (double) val2 * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i / 2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i / 2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i / 2) = (Py_Int32) val1;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="794" endline="797">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="805" endline="819">
{
    if (size == 1)
        val1 = (int) *CHARP (cp, i);
    else if (size == 2)
        val1 = (int) *SHORTP (cp, i);
    else if (size == 4)
        val1 = (int) *LONGP (cp, i);
    if (size == 1)
        val2 = (int) *CHARP (cp, i +1);
    else if (size == 2)
        val2 = (int) *SHORTP (cp, i +2);
    else if (size == 4)
        val2 = (int) *LONGP (cp, i +4);
    fval = (double) val1 * fac1 + (double) val2 * fac2;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val1 = (int) fval;
    if (size == 1)
        *CHARP (ncp, i / 2) = (signed char) val1;
    else if (size == 2)
        *SHORTP (ncp, i / 2) = (short) val1;
    else if (size == 4)
        *LONGP (ncp, i / 2) = (Py_Int32) val1;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="825" endline="874">
{
    signed char *cp, *ncp;
    int len, size, val1, val2, val = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tostereo", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * fac1;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        fval = (double) val * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val2 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i *2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i *2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i *2) = (Py_Int32) val1;
        if (size == 1)
            *CHARP (ncp, i *2 + 1) = (signed char) val2;
        else if (size == 2)
            *SHORTP (ncp, i *2 + 2) = (short) val2;
        else if (size == 4)
            *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="839" endline="842">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="850" endline="872">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    fval = (double) val * fac1;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val1 = (int) fval;
    fval = (double) val * fac2;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val2 = (int) fval;
    if (size == 1)
        *CHARP (ncp, i *2) = (signed char) val1;
    else if (size == 2)
        *SHORTP (ncp, i *2) = (short) val1;
    else if (size == 4)
        *LONGP (ncp, i *2) = (Py_Int32) val1;
    if (size == 1)
        *CHARP (ncp, i *2 + 1) = (signed char) val2;
    else if (size == 2)
        *SHORTP (ncp, i *2 + 2) = (short) val2;
    else if (size == 4)
        *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="878" endline="927">
{
    signed char *cp1, *cp2, *ncp;
    int len1, len2, size, val1 = 0, val2 = 0, maxval, newval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#s#i:add", &cp1, &len1, &cp2, &len2, &size))
        return 0;
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Lengths should be the same");
        return 0;
    }
    if (size == 1)
        maxval = 0x7f;
    else if (size == 2)
        maxval = 0x7fff;
    else if (size == 4)
        maxval = 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len1);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len1; i += size) {
        if (size == 1)
            val1 = (int) *CHARP (cp1, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp1, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp1, i);
        if (size == 1)
            val2 = (int) *CHARP (cp2, i);
        else if (size == 2)
            val2 = (int) *SHORTP (cp2, i);
        else if (size == 4)
            val2 = (int) *LONGP (cp2, i);
        newval = val1 + val2;
        if (newval > maxval)
            newval = maxval;
        else if (newval < -maxval)
            newval = -maxval;
        else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
            newval = val1 > 0 ? maxval : -maxval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) newval;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) newval;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) newval;
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="888" endline="891">
{
    PyErr_SetString (AudioopError, "Lengths should be the same");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="896" endline="899">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="906" endline="925">
{
    if (size == 1)
        val1 = (int) *CHARP (cp1, i);
    else if (size == 2)
        val1 = (int) *SHORTP (cp1, i);
    else if (size == 4)
        val1 = (int) *LONGP (cp1, i);
    if (size == 1)
        val2 = (int) *CHARP (cp2, i);
    else if (size == 2)
        val2 = (int) *SHORTP (cp2, i);
    else if (size == 4)
        val2 = (int) *LONGP (cp2, i);
    newval = val1 + val2;
    if (newval > maxval)
        newval = maxval;
    else if (newval < -maxval)
        newval = -maxval;
    else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
        newval = val1 > 0 ? maxval : -maxval;
    if (size == 1)
        *CHARP (ncp, i) = (signed char) newval;
    else if (size == 2)
        *SHORTP (ncp, i) = (short) newval;
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) newval;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="931" endline="963">
{
    signed char *cp, *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    int bias;
    if (!PyArg_ParseTuple (args, "s#ii:bias", &cp, &len, &size, &bias))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val + bias);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val + bias);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val + bias);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="942" endline="945">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="953" endline="961">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val + bias);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val + bias);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val + bias);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="967" endline="1000">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#i:reverse", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        j = len - i - size;
        if (size == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="978" endline="981">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="988" endline="998">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    j = len - i - size;
    if (size == 1)
        *CHARP (ncp, j) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, j) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, j) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1004" endline="1036">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, size2, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#ii:lin2lin", &cp, &len, &size, &size2))
        return 0;
    if ((size != 1 && size != 2 && size != 4) || (size2 != 1 && size2 != 2 && size2 != 4)) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, (len / size) * size2);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0, j = 0; i < len; i += size, j += size2) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        if (size2 == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size2 == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size2 == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1016" endline="1019">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1026" endline="1034">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    if (size2 == 1)
        *CHARP (ncp, j) = (signed char) (val >> 8);
    else if (size2 == 2)
        *SHORTP (ncp, j) = (short) (val);
    else if (size2 == 4)
        *LONGP (ncp, j) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1040" endline="1047">
{
    while (b > 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1041" endline="1045">
{
    int tmp = a % b;
    a = b;
    b = tmp;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1051" endline="1233">
{
    char *cp, *ncp;
    int len, size, nchannels, inrate, outrate, weightA, weightB;
    int chan, d, *prev_i, *cur_i, cur_o;
    PyObject *state, *samps, *str, *rv = NULL;
    int bytes_per_frame;
    weightA = 1;
    weightB = 0;
    if (!PyArg_ParseTuple (args, "s#iiiiO|ii:ratecv", &cp, &len, &size, &nchannels, &inrate, &outrate, &state, &weightA, &weightB))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    if (nchannels < 1) {
        PyErr_SetString (AudioopError, "# of channels should be >= 1");
        return NULL;
    }
    bytes_per_frame = size * nchannels;
    if (bytes_per_frame / nchannels != size) {
        PyErr_SetString (PyExc_OverflowError, "width * nchannels too big for a C int");
        return NULL;
    }
    if (weightA < 1 || weightB < 0) {
        PyErr_SetString (AudioopError, "weightA should be >= 1, weightB should be >= 0");
        return NULL;
    }
    if (len % bytes_per_frame != 0) {
        PyErr_SetString (AudioopError, "not a whole number of frames");
        return NULL;
    }
    if (inrate <= 0 || outrate <= 0) {
        PyErr_SetString (AudioopError, "sampling rate not > 0");
        return NULL;
    }
    d = gcd (inrate, outrate);
    inrate /= d;
    outrate /= d;
    prev_i = (int *) malloc (nchannels * sizeof (int));
    cur_i = (int *) malloc (nchannels * sizeof (int));
    if (prev_i == NULL || cur_i == NULL) {
        (void) PyErr_NoMemory ();
        goto exit;
    }
    len /= bytes_per_frame;
    if (state == Py_None) {
        d = -outrate;
        for (chan = 0; chan < nchannels; chan++)
            prev_i[chan] = cur_i[chan] = 0;
    }
    else {
        if (!PyArg_ParseTuple (state, "iO!;audioop.ratecv: illegal state argument", &d, &PyTuple_Type, &samps))
            goto exit;
        if (PyTuple_Size (samps) != nchannels) {
            PyErr_SetString (AudioopError, "illegal state argument");
            goto exit;
        }
        for (chan = 0; chan < nchannels; chan++) {
            if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
                goto exit;
        }
    }
    {
        int ceiling;
        int nbytes;
        int q = len / inrate;
        ceiling = (q + 1) * outrate;
        nbytes = ceiling * bytes_per_frame;
        if (q + 1 < 0 || ceiling / outrate != q + 1 || nbytes / bytes_per_frame != ceiling)
            str = NULL;
        else
            str = PyString_FromStringAndSize (NULL, nbytes);
        if (str == NULL) {
            PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
            goto exit;
        }
    }
    ncp = PyString_AsString (str);
    for (;;) {
        while (d < 0) {
            if (len == 0) {
                samps = PyTuple_New (nchannels);
                if (samps == NULL)
                    goto exit;
                for (chan = 0; chan < nchannels; chan++)
                    PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
                if (PyErr_Occurred ())
                    goto exit;
                len = (int) (ncp - PyString_AsString (str));
                if (len == 0) {
                    rv = PyString_FromStringAndSize ("", 0);
                    Py_DECREF (str);
                    str = rv;
                }
                else if (_PyString_Resize (&str, len) < 0)
                    goto exit;
                rv = Py_BuildValue ("(O(iO))", str, d, samps);
                Py_DECREF (samps);
                Py_DECREF (str);
                goto exit;
            }
            for (chan = 0; chan < nchannels; chan++) {
                prev_i[chan] = cur_i[chan];
                if (size == 1)
                    cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
                else if (size == 2)
                    cur_i[chan] = (int) *SHORTP (cp, 0);
                else if (size == 4)
                    cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
                cp += size;
                cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
            }
            len--;
            d += outrate;
        }
        while (d >= 0) {
            for (chan = 0; chan < nchannels; chan++) {
                cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
                if (size == 1)
                    *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
                else if (size == 2)
                    *SHORTP (ncp, 0) = (short) (cur_o);
                else if (size == 4)
                    *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
                ncp += size;
            }
            d -= inrate;
        }
    }
exit :
    if (prev_i != NULL)
        free (prev_i);
    if (cur_i != NULL)
        free (cur_i);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1064" endline="1067">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1068" endline="1071">
{
    PyErr_SetString (AudioopError, "# of channels should be >= 1");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1073" endline="1080">
{
    PyErr_SetString (PyExc_OverflowError, "width * nchannels too big for a C int");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1081" endline="1085">
{
    PyErr_SetString (AudioopError, "weightA should be >= 1, weightB should be >= 0");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1086" endline="1089">
{
    PyErr_SetString (AudioopError, "not a whole number of frames");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1090" endline="1093">
{
    PyErr_SetString (AudioopError, "sampling rate not > 0");
    return NULL;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1101" endline="1104">
{
    (void) PyErr_NoMemory ();
    goto exit;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1108" endline="1112">
{
    d = -outrate;
    for (chan = 0; chan < nchannels; chan++)
        prev_i[chan] = cur_i[chan] = 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1113" endline="1129">
{
    if (!PyArg_ParseTuple (state, "iO!;audioop.ratecv: illegal state argument", &d, &PyTuple_Type, &samps))
        goto exit;
    if (PyTuple_Size (samps) != nchannels) {
        PyErr_SetString (AudioopError, "illegal state argument");
        goto exit;
    }
    for (chan = 0; chan < nchannels; chan++) {
        if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
            goto exit;
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1118" endline="1122">
{
    PyErr_SetString (AudioopError, "illegal state argument");
    goto exit;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1123" endline="1128">
{
    if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
        goto exit;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1132" endline="1162">
{
    int ceiling;
    int nbytes;
    int q = len / inrate;
    ceiling = (q + 1) * outrate;
    nbytes = ceiling * bytes_per_frame;
    if (q + 1 < 0 || ceiling / outrate != q + 1 || nbytes / bytes_per_frame != ceiling)
        str = NULL;
    else
        str = PyString_FromStringAndSize (NULL, nbytes);
    if (str == NULL) {
        PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
        goto exit;
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1157" endline="1161">
{
    PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
    goto exit;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1165" endline="1226">
{
    while (d < 0) {
        if (len == 0) {
            samps = PyTuple_New (nchannels);
            if (samps == NULL)
                goto exit;
            for (chan = 0; chan < nchannels; chan++)
                PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
            if (PyErr_Occurred ())
                goto exit;
            len = (int) (ncp - PyString_AsString (str));
            if (len == 0) {
                rv = PyString_FromStringAndSize ("", 0);
                Py_DECREF (str);
                str = rv;
            }
            else if (_PyString_Resize (&str, len) < 0)
                goto exit;
            rv = Py_BuildValue ("(O(iO))", str, d, samps);
            Py_DECREF (samps);
            Py_DECREF (str);
            goto exit;
        }
        for (chan = 0; chan < nchannels; chan++) {
            prev_i[chan] = cur_i[chan];
            if (size == 1)
                cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
            else if (size == 2)
                cur_i[chan] = (int) *SHORTP (cp, 0);
            else if (size == 4)
                cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
            cp += size;
            cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
        }
        len--;
        d += outrate;
    }
    while (d >= 0) {
        for (chan = 0; chan < nchannels; chan++) {
            cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
            if (size == 1)
                *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
            else if (size == 2)
                *SHORTP (ncp, 0) = (short) (cur_o);
            else if (size == 4)
                *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
            ncp += size;
        }
        d -= inrate;
    }
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1166" endline="1210">
{
    if (len == 0) {
        samps = PyTuple_New (nchannels);
        if (samps == NULL)
            goto exit;
        for (chan = 0; chan < nchannels; chan++)
            PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
        if (PyErr_Occurred ())
            goto exit;
        len = (int) (ncp - PyString_AsString (str));
        if (len == 0) {
            rv = PyString_FromStringAndSize ("", 0);
            Py_DECREF (str);
            str = rv;
        }
        else if (_PyString_Resize (&str, len) < 0)
            goto exit;
        rv = Py_BuildValue ("(O(iO))", str, d, samps);
        Py_DECREF (samps);
        Py_DECREF (str);
        goto exit;
    }
    for (chan = 0; chan < nchannels; chan++) {
        prev_i[chan] = cur_i[chan];
        if (size == 1)
            cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
        else if (size == 2)
            cur_i[chan] = (int) *SHORTP (cp, 0);
        else if (size == 4)
            cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
        cp += size;
        cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
    }
    len--;
    d += outrate;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1167" endline="1192">
{
    samps = PyTuple_New (nchannels);
    if (samps == NULL)
        goto exit;
    for (chan = 0; chan < nchannels; chan++)
        PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
    if (PyErr_Occurred ())
        goto exit;
    len = (int) (ncp - PyString_AsString (str));
    if (len == 0) {
        rv = PyString_FromStringAndSize ("", 0);
        Py_DECREF (str);
        str = rv;
    }
    else if (_PyString_Resize (&str, len) < 0)
        goto exit;
    rv = Py_BuildValue ("(O(iO))", str, d, samps);
    Py_DECREF (samps);
    Py_DECREF (str);
    goto exit;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1181" endline="1186">
{
    rv = PyString_FromStringAndSize ("", 0);
    Py_DECREF (str);
    str = rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1193" endline="1207">
{
    prev_i[chan] = cur_i[chan];
    if (size == 1)
        cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
    else if (size == 2)
        cur_i[chan] = (int) *SHORTP (cp, 0);
    else if (size == 4)
        cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
    cp += size;
    cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1211" endline="1225">
{
    for (chan = 0; chan < nchannels; chan++) {
        cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
        if (size == 1)
            *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
        else if (size == 2)
            *SHORTP (ncp, 0) = (short) (cur_o);
        else if (size == 4)
            *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
        ncp += size;
    }
    d -= inrate;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1212" endline="1223">
{
    cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
    if (size == 1)
        *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
    else if (size == 2)
        *SHORTP (ncp, 0) = (short) (cur_o);
    else if (size == 4)
        *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
    ncp += size;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1237" endline="1266">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2ulaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_14linear2ulaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1248" endline="1251">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1258" endline="1264">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    *ncp++ = st_14linear2ulaw (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1270" endline="1301">
{
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:ulaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_ulaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1282" endline="1285">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1292" endline="1299">
{
    cval = *cp++;
    val = st_ulaw2linear16 (cval);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1305" endline="1334">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2alaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_linear2alaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1316" endline="1319">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1326" endline="1332">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    *ncp++ = st_linear2alaw (val);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1338" endline="1369">
{
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:alaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_alaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1350" endline="1353">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1360" endline="1367">
{
    cval = *cp++;
    val = st_alaw2linear16 (cval);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1373" endline="1478">
{
    signed char *cp;
    signed char *ncp;
    int len, size, val = 0, step, valpred, delta, index, sign, vpdiff, diff;
    PyObject *rv, *state, *str;
    int i, outputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:lin2adpcm", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    str = PyString_FromStringAndSize (NULL, len / (size * 2));
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    step = stepsizeTable[index];
    bufferstep = 1;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        diff = val - valpred;
        sign = (diff < 0) ? 8 : 0;
        if (sign)
            diff = (-diff);
        delta = 0;
        vpdiff = (step >> 3);
        if (diff >= step) {
            delta = 4;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 2;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 1;
            vpdiff += step;
        }
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        delta |= sign;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        step = stepsizeTable[index];
        if (bufferstep) {
            outputbuffer = (delta << 4) & 0xf0;
        }
        else {
            *ncp++ = (delta & 0x0f) | outputbuffer;
        }
        bufferstep = !bufferstep;
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1386" endline="1389">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1397" endline="1402">
{
    valpred = 0;
    step = 7;
    index = 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1408" endline="1474">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    diff = val - valpred;
    sign = (diff < 0) ? 8 : 0;
    if (sign)
        diff = (-diff);
    delta = 0;
    vpdiff = (step >> 3);
    if (diff >= step) {
        delta = 4;
        diff -= step;
        vpdiff += step;
    }
    step >>= 1;
    if (diff >= step) {
        delta |= 2;
        diff -= step;
        vpdiff += step;
    }
    step >>= 1;
    if (diff >= step) {
        delta |= 1;
        vpdiff += step;
    }
    if (sign)
        valpred -= vpdiff;
    else
        valpred += vpdiff;
    if (valpred > 32767)
        valpred = 32767;
    else if (valpred < -32768)
        valpred = -32768;
    delta |= sign;
    index += indexTable[delta];
    if (index < 0)
        index = 0;
    if (index > 88)
        index = 88;
    step = stepsizeTable[index];
    if (bufferstep) {
        outputbuffer = (delta << 4) & 0xf0;
    }
    else {
        *ncp++ = (delta & 0x0f) | outputbuffer;
    }
    bufferstep = !bufferstep;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1430" endline="1434">
{
    delta = 4;
    diff -= step;
    vpdiff += step;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1436" endline="1440">
{
    delta |= 2;
    diff -= step;
    vpdiff += step;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1442" endline="1445">
{
    delta |= 1;
    vpdiff += step;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1468" endline="1470">
{
    outputbuffer = (delta << 4) & 0xf0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1470" endline="1472">
{
    *ncp++ = (delta & 0x0f) | outputbuffer;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1482" endline="1568">
{
    signed char *cp;
    signed char *ncp;
    int len, size, valpred, step, delta, index, sign, vpdiff;
    PyObject *rv, *str, *state;
    int i, inputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:adpcm2lin", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    str = PyString_FromStringAndSize (NULL, len *size * 2);
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    step = stepsizeTable[index];
    bufferstep = 0;
    for (i = 0; i < len * size * 2; i += size) {
        if (bufferstep) {
            delta = inputbuffer & 0xf;
        }
        else {
            inputbuffer = *cp++;
            delta = (inputbuffer >> 4) & 0xf;
        }
        bufferstep = !bufferstep;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        sign = delta & 8;
        delta = delta & 7;
        vpdiff = step >> 3;
        if (delta & 4)
            vpdiff += step;
        if (delta & 2)
            vpdiff += step >> 1;
        if (delta & 1)
            vpdiff += step >> 2;
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        step = stepsizeTable[index];
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (valpred >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (valpred);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1493" endline="1496">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1499" endline="1504">
{
    valpred = 0;
    step = 7;
    index = 0;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1515" endline="1563">
{
    if (bufferstep) {
        delta = inputbuffer & 0xf;
    }
    else {
        inputbuffer = *cp++;
        delta = (inputbuffer >> 4) & 0xf;
    }
    bufferstep = !bufferstep;
    index += indexTable[delta];
    if (index < 0)
        index = 0;
    if (index > 88)
        index = 88;
    sign = delta & 8;
    delta = delta & 7;
    vpdiff = step >> 3;
    if (delta & 4)
        vpdiff += step;
    if (delta & 2)
        vpdiff += step >> 1;
    if (delta & 1)
        vpdiff += step >> 2;
    if (sign)
        valpred -= vpdiff;
    else
        valpred += vpdiff;
    if (valpred > 32767)
        valpred = 32767;
    else if (valpred < -32768)
        valpred = -32768;
    step = stepsizeTable[index];
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (valpred >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (valpred);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1517" endline="1519">
{
    delta = inputbuffer & 0xf;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1519" endline="1522">
{
    inputbuffer = *cp++;
    delta = (inputbuffer >> 4) & 0xf;
}
</source>
<source file="examples2/python//audioop.c.ifdefed" startline="1601" endline="1612">
{
    PyObject *m, *d;
    m = Py_InitModule ("audioop", audioop_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (d == NULL)
        return;
    AudioopError = PyErr_NewException ("audioop.error", NULL, NULL);
    if (AudioopError != NULL)
        PyDict_SetItemString (d, "error", AudioopError);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="20" endline="27">
{
    int fd = PyObject_AsFileDescriptor (object);
    if (fd < 0)
        return 0;
    *target = fd;
    return 1;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="34" endline="77">
{
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    char buf [1024];
    if (PyArg_ParseTuple (args, "O&is#:fcntl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > sizeof buf) {
            PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&i|i;fcntl requires a file or file descriptor," " an integer and optionally a third integer or a string", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="44" endline="59">
{
    if (len > sizeof buf) {
        PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
        return NULL;
    }
    memcpy (buf, str, len);
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, buf);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="45" endline="49">
{
    PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="54" endline="57">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="66" endline="68">
{
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="72" endline="75">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="97" endline="203">
{
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    int mutate_arg = 1;
    char buf [IOCTL_BUFSZ + 1];
    if (PyArg_ParseTuple (args, "O&Iw#|i:ioctl", conv_descriptor, &fd, &code, &str, &len, &mutate_arg)) {
        char *arg;
        if (mutate_arg) {
            if (len <= IOCTL_BUFSZ) {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
            else {
                arg = str;
            }
        }
        else {
            if (len > IOCTL_BUFSZ) {
                PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
                return NULL;
            }
            else {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
        }
        if (buf == arg) {
            Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
            Py_END_ALLOW_THREADS
        }
        else {
            ret = ioctl (fd, code, arg);
        }
        if (mutate_arg && (len < IOCTL_BUFSZ)) {
            memcpy (str, buf, len);
        }
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        if (mutate_arg) {
            return PyInt_FromLong (ret);
        }
        else {
            return PyString_FromStringAndSize (buf, len);
        }
    }
    PyErr_Clear ();
    if (PyArg_ParseTuple (args, "O&Is#:ioctl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > IOCTL_BUFSZ) {
            PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        buf[len] = '\0';
        Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&I|i;ioctl requires a file or file descriptor," " an integer and optionally an integer or buffer argument", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="114" endline="160">
{
    char *arg;
    if (mutate_arg) {
        if (len <= IOCTL_BUFSZ) {
            memcpy (buf, str, len);
            buf[len] = '\0';
            arg = buf;
        }
        else {
            arg = str;
        }
    }
    else {
        if (len > IOCTL_BUFSZ) {
            PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
            return NULL;
        }
        else {
            memcpy (buf, str, len);
            buf[len] = '\0';
            arg = buf;
        }
    }
    if (buf == arg) {
        Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
        Py_END_ALLOW_THREADS
    }
    else {
        ret = ioctl (fd, code, arg);
    }
    if (mutate_arg && (len < IOCTL_BUFSZ)) {
        memcpy (str, buf, len);
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    if (mutate_arg) {
        return PyInt_FromLong (ret);
    }
    else {
        return PyString_FromStringAndSize (buf, len);
    }
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="117" endline="126">
{
    if (len <= IOCTL_BUFSZ) {
        memcpy (buf, str, len);
        buf[len] = '\0';
        arg = buf;
    }
    else {
        arg = str;
    }
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="118" endline="122">
{
    memcpy (buf, str, len);
    buf[len] = '\0';
    arg = buf;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="123" endline="125">
{
    arg = str;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="127" endline="138">
{
    if (len > IOCTL_BUFSZ) {
        PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
        return NULL;
    }
    else {
        memcpy (buf, str, len);
        buf[len] = '\0';
        arg = buf;
    }
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="128" endline="132">
{
    PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="133" endline="137">
{
    memcpy (buf, str, len);
    buf[len] = '\0';
    arg = buf;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="139" endline="143">
{
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="144" endline="146">
{
    ret = ioctl (fd, code, arg);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="147" endline="149">
{
    memcpy (str, buf, len);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="150" endline="153">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="154" endline="156">
{
    return PyInt_FromLong (ret);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="157" endline="159">
{
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="164" endline="180">
{
    if (len > IOCTL_BUFSZ) {
        PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
        return NULL;
    }
    memcpy (buf, str, len);
    buf[len] = '\0';
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, buf);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="165" endline="169">
{
    PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="175" endline="178">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="187" endline="189">
{
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="197" endline="200">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="241" endline="287">
{
    int fd;
    int code;
    int ret;
    if (!PyArg_ParseTuple (args, "O&i:flock", conv_descriptor, &fd, &code))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
            return NULL;
        }
        l.l_whence = l.l_start = l.l_len = 0;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="262" endline="279">
{
    struct flock l;
    if (code == LOCK_UN)
        l.l_type = F_UNLCK;
    else if (code & LOCK_SH)
        l.l_type = F_RDLCK;
    else if (code & LOCK_EX)
        l.l_type = F_WRLCK;
    else {
        PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
        return NULL;
    }
    l.l_whence = l.l_start = l.l_len = 0;
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="270" endline="274">
{
    PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="281" endline="284">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="300" endline="368">
{
    int fd, code, ret, whence = 0;
    PyObject *lenobj = NULL, *startobj = NULL;
    if (!PyArg_ParseTuple (args, "O&i|OOi:lockf", conv_descriptor, &fd, &code, &lenobj, &startobj, &whence))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
            return NULL;
        }
        l.l_start = l.l_len = 0;
        if (startobj != NULL) {
            l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        if (lenobj != NULL) {
            l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        l.l_whence = whence;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="320" endline="360">
{
    struct flock l;
    if (code == LOCK_UN)
        l.l_type = F_UNLCK;
    else if (code & LOCK_SH)
        l.l_type = F_RDLCK;
    else if (code & LOCK_EX)
        l.l_type = F_WRLCK;
    else {
        PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
        return NULL;
    }
    l.l_start = l.l_len = 0;
    if (startobj != NULL) {
        l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
        if (PyErr_Occurred ())
            return NULL;
    }
    if (lenobj != NULL) {
        l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
        if (PyErr_Occurred ())
            return NULL;
    }
    l.l_whence = whence;
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="328" endline="332">
{
    PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="334" endline="344">
{
    l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
    if (PyErr_Occurred ())
        return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="345" endline="355">
{
    l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
    if (PyErr_Occurred ())
        return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="361" endline="364">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="416" endline="423">
{
    PyObject *v = PyInt_FromLong (value);
    if (!v || PyDict_SetItemString (d, symbol, v) < 0)
        return -1;
    Py_DECREF (v);
    return 0;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="429" endline="588">
{
    if (ins (d, "LOCK_SH", (long) LOCK_SH))
        return -1;
    if (ins (d, "LOCK_EX", (long) LOCK_EX))
        return -1;
    if (ins (d, "LOCK_NB", (long) LOCK_NB))
        return -1;
    if (ins (d, "LOCK_UN", (long) LOCK_UN))
        return -1;
    return 0;
}
</source>
<source file="examples2/python//fcntlmodule.c.ifdefed" startline="592" endline="603">
{
    PyObject *m, *d;
    m = Py_InitModule3 ("fcntl", fcntl_methods, module_doc);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    all_ins (d);
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="104" endline="110">
{
    fpe_reset (sigfpe_handler);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="113" endline="257">
{
    fputs ("Operation not implemented\n", stderr);
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="260" endline="277">
{
    fputs ("Operation not implemented\n", stderr);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="280" endline="287">
{
    fpe_reset (sigfpe_handler);
    if (PyFPE_counter) {
        longjmp (PyFPE_jbuf, 1);
    }
    else {
        Py_FatalError ("Unprotected floating point exception");
    }
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="282" endline="284">
{
    longjmp (PyFPE_jbuf, 1);
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="284" endline="286">
{
    Py_FatalError ("Unprotected floating point exception");
}
</source>
<source file="examples2/python//fpectlmodule.c.ifdefed" startline="290" endline="299">
{
    PyObject *m, *d;
    m = Py_InitModule ("fpectl", fpectl_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpectl.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="62" endline="99">
{
    double r;
    fprintf (stderr, "overflow");
    r = overflow (1.e160);
    printerr (r);
    fprintf (stderr, "\ndiv by 0");
    r = db0 (0.0);
    printerr (r);
    fprintf (stderr, "\nnested outer");
    r = nest1 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested inner");
    r = nest1 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\ntrailing outer");
    r = nest1 (2, 2.0);
    printerr (r);
    fprintf (stderr, "\nnested prior");
    r = nest2 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested interior");
    r = nest2 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\nnested trailing");
    r = nest2 (2, 2.0);
    printerr (r);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="102" endline="110">
{
    if (r == 3.1416) {
        fprintf (stderr, "\tPASS\n");
        PyErr_Print ();
    }
    else {
        fprintf (stderr, "\tFAIL\n");
    }
    PyErr_Clear ();
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="103" endline="106">
{
    fprintf (stderr, "\tPASS\n");
    PyErr_Print ();
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="106" endline="108">
{
    fprintf (stderr, "\tFAIL\n");
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="113" endline="130">
{
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, outer zone", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        PyFPE_START_PROTECT ("Division by zero, inner zone", return 3.1416)
        a = 1./ (1.- x);
        PyFPE_END_PROTECT (a)
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="117" endline="119">
{
    a = 1./ x;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="119" endline="124">
{
    PyFPE_START_PROTECT ("Division by zero, inner zone", return 3.1416)
    a = 1./ (1.- x);
    PyFPE_END_PROTECT (a)
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="124" endline="126">
{
    a = 1./ (2.- x);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="133" endline="145">
{
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, prior error", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        a = nest3 (x);
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="136" endline="138">
{
    a = 1./ x;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="138" endline="140">
{
    a = nest3 (x);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="140" endline="142">
{
    a = 1./ (2.- x);
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="148" endline="155">
{
    double result;
    PyFPE_START_PROTECT ("Division by zero, nest3 error", return 3.1416)
    result = 1./ (1.- x);
    PyFPE_END_PROTECT (result)
    return result;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="158" endline="164">
{
    double a;
    PyFPE_START_PROTECT ("Division by zero", return 3.1416)
    a = 1./ x;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="167" endline="173">
{
    double a;
    PyFPE_START_PROTECT ("Overflow", return 3.1416)
    a = b * b;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//fpetestmodule.c.ifdefed" startline="176" endline="186">
{
    PyObject *m, *d;
    m = Py_InitModule ("fpetest", fpetest_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpetest.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="37" endline="84">
{
    int setIndex = 0;
    PyObject *v = PyStructSequence_New (&StructGrpType), *w;
    char **member;
    if (v == NULL)
        return NULL;
    if ((w = PyList_New (0)) == NULL) {
        Py_DECREF (v);
        return NULL;
    }
    for (member = p->gr_mem; *member != NULL; member++) {
        PyObject *x = PyString_FromString (*member);
        if (x == NULL || PyList_Append (w, x) != 0) {
            Py_XDECREF (x);
            Py_DECREF (w);
            Py_DECREF (v);
            return NULL;
        }
        Py_DECREF (x);
    }
    SET (setIndex ++, PyString_FromString (p -> gr_name));
    if (p->gr_passwd)
        SET (setIndex++, PyString_FromString (p->gr_passwd));
    else {
        SET (setIndex ++, Py_None);
        Py_INCREF (Py_None);
    }
    SET (setIndex ++, PyInt_FromLong ((long) p -> gr_gid));
    SET (setIndex ++, w);
    if (PyErr_Occurred ()) {
        Py_DECREF (v);
        Py_DECREF (w);
        return NULL;
    }
    return v;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="45" endline="48">
{
    Py_DECREF (v);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="49" endline="58">
{
    PyObject *x = PyString_FromString (*member);
    if (x == NULL || PyList_Append (w, x) != 0) {
        Py_XDECREF (x);
        Py_DECREF (w);
        Py_DECREF (v);
        return NULL;
    }
    Py_DECREF (x);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="51" endline="56">
{
    Py_XDECREF (x);
    Py_DECREF (w);
    Py_DECREF (v);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="68" endline="71">
{
    SET (setIndex ++, Py_None);
    Py_INCREF (Py_None);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="77" endline="81">
{
    Py_DECREF (v);
    Py_DECREF (w);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="88" endline="104">
{
    PyObject *py_int_id;
    unsigned int gid;
    struct group *p;
    py_int_id = PyNumber_Int (pyo_id);
    if (!py_int_id)
        return NULL;
    gid = PyInt_AS_LONG (py_int_id);
    Py_DECREF (py_int_id);
    if ((p = getgrgid (gid)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
        return NULL;
    }
    return mkgrent (p);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="99" endline="102">
{
    PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="108" endline="126">
{
    PyObject *py_str_name;
    char *name;
    struct group *p;
    py_str_name = PyObject_Str (pyo_name);
    if (!py_str_name)
        return NULL;
    name = PyString_AS_STRING (py_str_name);
    if ((p = getgrnam (name)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
        Py_DECREF (py_str_name);
        return NULL;
    }
    Py_DECREF (py_str_name);
    return mkgrent (p);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="118" endline="122">
{
    PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
    Py_DECREF (py_str_name);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="130" endline="148">
{
    PyObject *d;
    struct group *p;
    if ((d = PyList_New (0)) == NULL)
        return NULL;
    setgrent ();
    while ((p = getgrent ()) != NULL) {
        PyObject *v = mkgrent (p);
        if (v == NULL || PyList_Append (d, v) != 0) {
            Py_XDECREF (v);
            Py_DECREF (d);
            return NULL;
        }
        Py_DECREF (v);
    }
    endgrent ();
    return d;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="137" endline="145">
{
    PyObject *v = mkgrent (p);
    if (v == NULL || PyList_Append (d, v) != 0) {
        Py_XDECREF (v);
        Py_DECREF (d);
        return NULL;
    }
    Py_DECREF (v);
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="139" endline="143">
{
    Py_XDECREF (v);
    Py_DECREF (d);
    return NULL;
}
</source>
<source file="examples2/python//grpmodule.c.ifdefed" startline="184" endline="194">
{
    PyObject *m, *d;
    m = Py_InitModule3 ("grp", grp_methods, grp__doc__);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (!initialized)
        PyStructSequence_InitType (&StructGrpType, &struct_group_type_desc);
    PyDict_SetItemString (d, "struct_group", (PyObject *) & StructGrpType);
    initialized = 1;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="55" endline="63">
{
    int i;
    for (i = 0; i < size; i++) {
        if (val <= *table++)
            return (i);
    }
    return (size);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="58" endline="61">
{
    if (val <= *table++)
        return (i);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="141" endline="174">
{
    PyInt16 mask;
    PyInt16 seg;
    unsigned char uval;
    pcm_val = pcm_val >> 2;
    if (pcm_val < 0) {
        pcm_val = -pcm_val;
        mask = 0x7F;
    }
    else {
        mask = 0xFF;
    }
    if (pcm_val > CLIP)
        pcm_val = CLIP;
    pcm_val += (BIAS >> 2);
    seg = search (pcm_val, seg_uend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);
        return (uval ^ mask);
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="151" endline="154">
{
    pcm_val = -pcm_val;
    mask = 0x7F;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="154" endline="156">
{
    mask = 0xFF;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="169" endline="172">
{
    uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);
    return (uval ^ mask);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="238" endline="269">
{
    PyInt16 mask;
    short seg;
    unsigned char aval;
    pcm_val = pcm_val >> 3;
    if (pcm_val >= 0) {
        mask = 0xD5;
    }
    else {
        mask = 0x55;
        pcm_val = -pcm_val - 1;
    }
    seg = search (pcm_val, seg_aend, 8);
    if (seg >= 8)
        return (unsigned char) (0x7F ^ mask);
    else {
        aval = (unsigned char) seg << SEG_SHIFT;
        if (seg < 2)
            aval |= (pcm_val >> 1) & QUANT_MASK;
        else
            aval |= (pcm_val >> seg) & QUANT_MASK;
        return (aval ^ mask);
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="247" endline="249">
{
    mask = 0xD5;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="249" endline="252">
{
    mask = 0x55;
    pcm_val = -pcm_val - 1;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="261" endline="268">
{
    aval = (unsigned char) seg << SEG_SHIFT;
    if (seg < 2)
        aval |= (pcm_val >> 1) & QUANT_MASK;
    else
        aval |= (pcm_val >> seg) & QUANT_MASK;
    return (aval ^ mask);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="300" endline="319">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    if (!PyArg_ParseTuple (args, "s#ii:getsample", &cp, &len, &size, &i))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (i < 0 || i >= len / size) {
        PyErr_SetString (AudioopError, "Index out of range");
        return 0;
    }
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i *2);
    else if (size == 4)
        val = (int) *LONGP (cp, i *4);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="307" endline="310">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="311" endline="314">
{
    PyErr_SetString (AudioopError, "Index out of range");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="323" endline="343">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int max = 0;
    if (!PyArg_ParseTuple (args, "s#i:max", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val < 0)
            val = (-val);
        if (val > max)
            max = val;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="331" endline="334">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="335" endline="341">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (val < 0)
        val = (-val);
    if (val > max)
        max = val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="347" endline="367">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int min = 0x7fffffff, max = -0x7fffffff;
    if (!PyArg_ParseTuple (args, "s#i:minmax", &cp, &len, &size))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val > max)
            max = val;
        if (val < min)
            min = val;
    }
    return Py_BuildValue ("(ii)", min, max);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="355" endline="358">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="359" endline="365">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (val > max)
        max = val;
    if (val < min)
        min = val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="371" endline="394">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    double avg = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:avg", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        avg += val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) (avg / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="379" endline="382">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="383" endline="388">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    avg += val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="398" endline="421">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    double sum_squares = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:rms", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        sum_squares += (double) val * (double) val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) sqrt (sum_squares / (double) (len / size));
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="406" endline="409">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="410" endline="415">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    sum_squares += (double) val * (double) val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="424" endline="432">
{
    int i;
    double sum = 0.0;
    for (i = 0; i < len; i++) {
        sum = sum + (double) a[i] * (double) b[i];
    }
    return sum;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="428" endline="430">
{
    sum = sum + (double) a[i] * (double) b[i];
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="468" endline="519">
{
    short *cp1, *cp2;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double sum_ri_2, sum_aij_2, sum_aij_ri, result, best_result, factor;
    if (!PyArg_ParseTuple (args, "s#s#:findfit", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    len2 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "First sample should be longer");
        return 0;
    }
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_2 = _sum2 (cp1, cp1, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        sum_aij_2 = sum_aij_2 + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        sum_aij_ri = _sum2 (cp1 +j, cp2, len2);
        result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
        if (result < best_result) {
            best_result = result;
            best_j = j;
        }
    }
    factor = _sum2 (cp1 +best_j, cp2, len2) / sum_ri_2;
    return Py_BuildValue ("(if)", best_j, factor);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="478" endline="481">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="485" endline="488">
{
    PyErr_SetString (AudioopError, "First sample should be longer");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="499" endline="514">
{
    aj_m1 = (double) cp1[j - 1];
    aj_lm1 = (double) cp1[j + len2 - 1];
    sum_aij_2 = sum_aij_2 + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
    sum_aij_ri = _sum2 (cp1 +j, cp2, len2);
    result = (sum_ri_2 * sum_aij_2 - sum_aij_ri * sum_aij_ri) / sum_aij_2;
    if (result < best_result) {
        best_result = result;
        best_j = j;
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="509" endline="512">
{
    best_result = result;
    best_j = j;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="527" endline="550">
{
    short *cp1, *cp2;
    int len1, len2;
    double sum_ri_2, sum_aij_ri, result;
    if (!PyArg_ParseTuple (args, "s#s#:findfactor", &cp1, &len1, &cp2, &len2))
        return 0;
    if (len1 & 1 || len2 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Samples should be same size");
        return 0;
    }
    len2 >>= 1;
    sum_ri_2 = _sum2 (cp2, cp2, len2);
    sum_aij_ri = _sum2 (cp1, cp2, len2);
    result = sum_aij_ri / sum_ri_2;
    return PyFloat_FromDouble (result);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="535" endline="538">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="539" endline="542">
{
    PyErr_SetString (AudioopError, "Samples should be same size");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="558" endline="598">
{
    short *cp1;
    int len1, len2;
    int j, best_j;
    double aj_m1, aj_lm1;
    double result, best_result;
    if (!PyArg_ParseTuple (args, "s#i:findmax", &cp1, &len1, &len2))
        return 0;
    if (len1 & 1) {
        PyErr_SetString (AudioopError, "Strings should be even-sized");
        return 0;
    }
    len1 >>= 1;
    if (len1 < len2) {
        PyErr_SetString (AudioopError, "Input sample should be longer");
        return 0;
    }
    result = _sum2 (cp1, cp1, len2);
    best_result = result;
    best_j = 0;
    j = 0;
    for (j = 1; j <= len1 - len2; j++) {
        aj_m1 = (double) cp1[j - 1];
        aj_lm1 = (double) cp1[j + len2 - 1];
        result = result + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
        if (result > best_result) {
            best_result = result;
            best_j = j;
        }
    }
    return PyInt_FromLong (best_j);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="567" endline="570">
{
    PyErr_SetString (AudioopError, "Strings should be even-sized");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="573" endline="576">
{
    PyErr_SetString (AudioopError, "Input sample should be longer");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="584" endline="595">
{
    aj_m1 = (double) cp1[j - 1];
    aj_lm1 = (double) cp1[j + len2 - 1];
    result = result + aj_lm1 * aj_lm1 - aj_m1 * aj_m1;
    if (result > best_result) {
        best_result = result;
        best_j = j;
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="590" endline="593">
{
    best_result = result;
    best_j = j;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="602" endline="655">
{
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    double avg = 0.0;
    int diff, prevdiff, extremediff, nextreme = 0;
    if (!PyArg_ParseTuple (args, "s#i:avgpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                avg += extremediff;
                nextreme++;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    if (nextreme == 0)
        val = 0;
    else
        val = (int) (avg / (double) nextreme);
    return PyInt_FromLong (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="612" endline="615">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="627" endline="649">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    diff = val - prevval;
    if (diff * prevdiff < 0) {
        if (prevextremevalid) {
            extremediff = prevval - prevextreme;
            if (extremediff < 0)
                extremediff = -extremediff;
            avg += extremediff;
            nextreme++;
        }
        prevextremevalid = 1;
        prevextreme = prevval;
    }
    prevval = val;
    if (diff != 0)
        prevdiff = diff;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="632" endline="645">
{
    if (prevextremevalid) {
        extremediff = prevval - prevextreme;
        if (extremediff < 0)
            extremediff = -extremediff;
        avg += extremediff;
        nextreme++;
    }
    prevextremevalid = 1;
    prevextreme = prevval;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="636" endline="642">
{
    extremediff = prevval - prevextreme;
    if (extremediff < 0)
        extremediff = -extremediff;
    avg += extremediff;
    nextreme++;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="659" endline="708">
{
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    int max = 0;
    int diff, prevdiff, extremediff;
    if (!PyArg_ParseTuple (args, "s#i:maxpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                if (extremediff > max)
                    max = extremediff;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    return PyInt_FromLong (max);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="669" endline="672">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="684" endline="706">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    diff = val - prevval;
    if (diff * prevdiff < 0) {
        if (prevextremevalid) {
            extremediff = prevval - prevextreme;
            if (extremediff < 0)
                extremediff = -extremediff;
            if (extremediff > max)
                max = extremediff;
        }
        prevextremevalid = 1;
        prevextreme = prevval;
    }
    prevval = val;
    if (diff != 0)
        prevdiff = diff;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="689" endline="702">
{
    if (prevextremevalid) {
        extremediff = prevval - prevextreme;
        if (extremediff < 0)
            extremediff = -extremediff;
        if (extremediff > max)
            max = extremediff;
    }
    prevextremevalid = 1;
    prevextreme = prevval;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="693" endline="699">
{
    extremediff = prevval - prevextreme;
    if (extremediff < 0)
        extremediff = -extremediff;
    if (extremediff > max)
        max = extremediff;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="712" endline="735">
{
    signed char *cp;
    int len, size, val = 0;
    int i;
    int prevval, ncross;
    if (!PyArg_ParseTuple (args, "s#i:cross", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    ncross = -1;
    prevval = 17;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) >> 7;
        else if (size == 2)
            val = ((int) *SHORTP (cp, i)) >> 15;
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 31;
        val = val & 1;
        if (val != prevval)
            ncross++;
        prevval = val;
    }
    return PyInt_FromLong (ncross);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="720" endline="723">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="726" endline="733">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) >> 7;
    else if (size == 2)
        val = ((int) *SHORTP (cp, i)) >> 15;
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 31;
    val = val & 1;
    if (val != prevval)
        ncross++;
    prevval = val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="739" endline="776">
{
    signed char *cp, *ncp;
    int len, size, val = 0;
    double factor, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#id:mul", &cp, &len, &size, &factor))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * factor;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val = (int) fval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) val;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) val;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) val;
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="752" endline="755">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="763" endline="774">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    fval = (double) val * factor;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val = (int) fval;
    if (size == 1)
        *CHARP (ncp, i) = (signed char) val;
    else if (size == 2)
        *SHORTP (ncp, i) = (short) val;
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) val;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="780" endline="821">
{
    signed char *cp, *ncp;
    int len, size, val1 = 0, val2 = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tomono", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / 2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size * 2) {
        if (size == 1)
            val1 = (int) *CHARP (cp, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp, i);
        if (size == 1)
            val2 = (int) *CHARP (cp, i +1);
        else if (size == 2)
            val2 = (int) *SHORTP (cp, i +2);
        else if (size == 4)
            val2 = (int) *LONGP (cp, i +4);
        fval = (double) val1 * fac1 + (double) val2 * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i / 2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i / 2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i / 2) = (Py_Int32) val1;
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="794" endline="797">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="805" endline="819">
{
    if (size == 1)
        val1 = (int) *CHARP (cp, i);
    else if (size == 2)
        val1 = (int) *SHORTP (cp, i);
    else if (size == 4)
        val1 = (int) *LONGP (cp, i);
    if (size == 1)
        val2 = (int) *CHARP (cp, i +1);
    else if (size == 2)
        val2 = (int) *SHORTP (cp, i +2);
    else if (size == 4)
        val2 = (int) *LONGP (cp, i +4);
    fval = (double) val1 * fac1 + (double) val2 * fac2;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val1 = (int) fval;
    if (size == 1)
        *CHARP (ncp, i / 2) = (signed char) val1;
    else if (size == 2)
        *SHORTP (ncp, i / 2) = (short) val1;
    else if (size == 4)
        *LONGP (ncp, i / 2) = (Py_Int32) val1;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="825" endline="874">
{
    signed char *cp, *ncp;
    int len, size, val1, val2, val = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tostereo", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * fac1;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        fval = (double) val * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val2 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i *2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i *2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i *2) = (Py_Int32) val1;
        if (size == 1)
            *CHARP (ncp, i *2 + 1) = (signed char) val2;
        else if (size == 2)
            *SHORTP (ncp, i *2 + 2) = (short) val2;
        else if (size == 4)
            *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="839" endline="842">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="850" endline="872">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    fval = (double) val * fac1;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val1 = (int) fval;
    fval = (double) val * fac2;
    if (fval > maxval)
        fval = maxval;
    else if (fval < -maxval)
        fval = -maxval;
    val2 = (int) fval;
    if (size == 1)
        *CHARP (ncp, i *2) = (signed char) val1;
    else if (size == 2)
        *SHORTP (ncp, i *2) = (short) val1;
    else if (size == 4)
        *LONGP (ncp, i *2) = (Py_Int32) val1;
    if (size == 1)
        *CHARP (ncp, i *2 + 1) = (signed char) val2;
    else if (size == 2)
        *SHORTP (ncp, i *2 + 2) = (short) val2;
    else if (size == 4)
        *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="878" endline="927">
{
    signed char *cp1, *cp2, *ncp;
    int len1, len2, size, val1 = 0, val2 = 0, maxval, newval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#s#i:add", &cp1, &len1, &cp2, &len2, &size))
        return 0;
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Lengths should be the same");
        return 0;
    }
    if (size == 1)
        maxval = 0x7f;
    else if (size == 2)
        maxval = 0x7fff;
    else if (size == 4)
        maxval = 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len1);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len1; i += size) {
        if (size == 1)
            val1 = (int) *CHARP (cp1, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp1, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp1, i);
        if (size == 1)
            val2 = (int) *CHARP (cp2, i);
        else if (size == 2)
            val2 = (int) *SHORTP (cp2, i);
        else if (size == 4)
            val2 = (int) *LONGP (cp2, i);
        newval = val1 + val2;
        if (newval > maxval)
            newval = maxval;
        else if (newval < -maxval)
            newval = -maxval;
        else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
            newval = val1 > 0 ? maxval : -maxval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) newval;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) newval;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) newval;
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="888" endline="891">
{
    PyErr_SetString (AudioopError, "Lengths should be the same");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="896" endline="899">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="906" endline="925">
{
    if (size == 1)
        val1 = (int) *CHARP (cp1, i);
    else if (size == 2)
        val1 = (int) *SHORTP (cp1, i);
    else if (size == 4)
        val1 = (int) *LONGP (cp1, i);
    if (size == 1)
        val2 = (int) *CHARP (cp2, i);
    else if (size == 2)
        val2 = (int) *SHORTP (cp2, i);
    else if (size == 4)
        val2 = (int) *LONGP (cp2, i);
    newval = val1 + val2;
    if (newval > maxval)
        newval = maxval;
    else if (newval < -maxval)
        newval = -maxval;
    else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
        newval = val1 > 0 ? maxval : -maxval;
    if (size == 1)
        *CHARP (ncp, i) = (signed char) newval;
    else if (size == 2)
        *SHORTP (ncp, i) = (short) newval;
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) newval;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="931" endline="963">
{
    signed char *cp, *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    int bias;
    if (!PyArg_ParseTuple (args, "s#ii:bias", &cp, &len, &size, &bias))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val + bias);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val + bias);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val + bias);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="942" endline="945">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="953" endline="961">
{
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = (int) *LONGP (cp, i);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val + bias);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val + bias);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val + bias);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="967" endline="1000">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#i:reverse", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        j = len - i - size;
        if (size == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="978" endline="981">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="988" endline="998">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    j = len - i - size;
    if (size == 1)
        *CHARP (ncp, j) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, j) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, j) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1004" endline="1036">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, size2, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#ii:lin2lin", &cp, &len, &size, &size2))
        return 0;
    if ((size != 1 && size != 2 && size != 4) || (size2 != 1 && size2 != 2 && size2 != 4)) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, (len / size) * size2);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0, j = 0; i < len; i += size, j += size2) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        if (size2 == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size2 == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size2 == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1016" endline="1019">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1026" endline="1034">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    if (size2 == 1)
        *CHARP (ncp, j) = (signed char) (val >> 8);
    else if (size2 == 2)
        *SHORTP (ncp, j) = (short) (val);
    else if (size2 == 4)
        *LONGP (ncp, j) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1040" endline="1047">
{
    while (b > 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1041" endline="1045">
{
    int tmp = a % b;
    a = b;
    b = tmp;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1051" endline="1233">
{
    char *cp, *ncp;
    int len, size, nchannels, inrate, outrate, weightA, weightB;
    int chan, d, *prev_i, *cur_i, cur_o;
    PyObject *state, *samps, *str, *rv = NULL;
    int bytes_per_frame;
    weightA = 1;
    weightB = 0;
    if (!PyArg_ParseTuple (args, "s#iiiiO|ii:ratecv", &cp, &len, &size, &nchannels, &inrate, &outrate, &state, &weightA, &weightB))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    if (nchannels < 1) {
        PyErr_SetString (AudioopError, "# of channels should be >= 1");
        return NULL;
    }
    bytes_per_frame = size * nchannels;
    if (bytes_per_frame / nchannels != size) {
        PyErr_SetString (PyExc_OverflowError, "width * nchannels too big for a C int");
        return NULL;
    }
    if (weightA < 1 || weightB < 0) {
        PyErr_SetString (AudioopError, "weightA should be >= 1, weightB should be >= 0");
        return NULL;
    }
    if (len % bytes_per_frame != 0) {
        PyErr_SetString (AudioopError, "not a whole number of frames");
        return NULL;
    }
    if (inrate <= 0 || outrate <= 0) {
        PyErr_SetString (AudioopError, "sampling rate not > 0");
        return NULL;
    }
    d = gcd (inrate, outrate);
    inrate /= d;
    outrate /= d;
    prev_i = (int *) malloc (nchannels * sizeof (int));
    cur_i = (int *) malloc (nchannels * sizeof (int));
    if (prev_i == NULL || cur_i == NULL) {
        (void) PyErr_NoMemory ();
        goto exit;
    }
    len /= bytes_per_frame;
    if (state == Py_None) {
        d = -outrate;
        for (chan = 0; chan < nchannels; chan++)
            prev_i[chan] = cur_i[chan] = 0;
    }
    else {
        if (!PyArg_ParseTuple (state, "iO!;audioop.ratecv: illegal state argument", &d, &PyTuple_Type, &samps))
            goto exit;
        if (PyTuple_Size (samps) != nchannels) {
            PyErr_SetString (AudioopError, "illegal state argument");
            goto exit;
        }
        for (chan = 0; chan < nchannels; chan++) {
            if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
                goto exit;
        }
    }
    {
        int ceiling;
        int nbytes;
        int q = len / inrate;
        ceiling = (q + 1) * outrate;
        nbytes = ceiling * bytes_per_frame;
        if (q + 1 < 0 || ceiling / outrate != q + 1 || nbytes / bytes_per_frame != ceiling)
            str = NULL;
        else
            str = PyString_FromStringAndSize (NULL, nbytes);
        if (str == NULL) {
            PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
            goto exit;
        }
    }
    ncp = PyString_AsString (str);
    for (;;) {
        while (d < 0) {
            if (len == 0) {
                samps = PyTuple_New (nchannels);
                if (samps == NULL)
                    goto exit;
                for (chan = 0; chan < nchannels; chan++)
                    PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
                if (PyErr_Occurred ())
                    goto exit;
                len = (int) (ncp - PyString_AsString (str));
                if (len == 0) {
                    rv = PyString_FromStringAndSize ("", 0);
                    Py_DECREF (str);
                    str = rv;
                }
                else if (_PyString_Resize (&str, len) < 0)
                    goto exit;
                rv = Py_BuildValue ("(O(iO))", str, d, samps);
                Py_DECREF (samps);
                Py_DECREF (str);
                goto exit;
            }
            for (chan = 0; chan < nchannels; chan++) {
                prev_i[chan] = cur_i[chan];
                if (size == 1)
                    cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
                else if (size == 2)
                    cur_i[chan] = (int) *SHORTP (cp, 0);
                else if (size == 4)
                    cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
                cp += size;
                cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
            }
            len--;
            d += outrate;
        }
        while (d >= 0) {
            for (chan = 0; chan < nchannels; chan++) {
                cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
                if (size == 1)
                    *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
                else if (size == 2)
                    *SHORTP (ncp, 0) = (short) (cur_o);
                else if (size == 4)
                    *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
                ncp += size;
            }
            d -= inrate;
        }
    }
exit :
    if (prev_i != NULL)
        free (prev_i);
    if (cur_i != NULL)
        free (cur_i);
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1064" endline="1067">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1068" endline="1071">
{
    PyErr_SetString (AudioopError, "# of channels should be >= 1");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1073" endline="1080">
{
    PyErr_SetString (PyExc_OverflowError, "width * nchannels too big for a C int");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1081" endline="1085">
{
    PyErr_SetString (AudioopError, "weightA should be >= 1, weightB should be >= 0");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1086" endline="1089">
{
    PyErr_SetString (AudioopError, "not a whole number of frames");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1090" endline="1093">
{
    PyErr_SetString (AudioopError, "sampling rate not > 0");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1101" endline="1104">
{
    (void) PyErr_NoMemory ();
    goto exit;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1108" endline="1112">
{
    d = -outrate;
    for (chan = 0; chan < nchannels; chan++)
        prev_i[chan] = cur_i[chan] = 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1113" endline="1129">
{
    if (!PyArg_ParseTuple (state, "iO!;audioop.ratecv: illegal state argument", &d, &PyTuple_Type, &samps))
        goto exit;
    if (PyTuple_Size (samps) != nchannels) {
        PyErr_SetString (AudioopError, "illegal state argument");
        goto exit;
    }
    for (chan = 0; chan < nchannels; chan++) {
        if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
            goto exit;
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1118" endline="1122">
{
    PyErr_SetString (AudioopError, "illegal state argument");
    goto exit;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1123" endline="1128">
{
    if (!PyArg_ParseTuple (PyTuple_GetItem (samps, chan), "ii:ratecv", &prev_i[chan], &cur_i[chan]))
        goto exit;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1132" endline="1162">
{
    int ceiling;
    int nbytes;
    int q = len / inrate;
    ceiling = (q + 1) * outrate;
    nbytes = ceiling * bytes_per_frame;
    if (q + 1 < 0 || ceiling / outrate != q + 1 || nbytes / bytes_per_frame != ceiling)
        str = NULL;
    else
        str = PyString_FromStringAndSize (NULL, nbytes);
    if (str == NULL) {
        PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
        goto exit;
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1157" endline="1161">
{
    PyErr_SetString (PyExc_MemoryError, "not enough memory for output buffer");
    goto exit;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1165" endline="1226">
{
    while (d < 0) {
        if (len == 0) {
            samps = PyTuple_New (nchannels);
            if (samps == NULL)
                goto exit;
            for (chan = 0; chan < nchannels; chan++)
                PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
            if (PyErr_Occurred ())
                goto exit;
            len = (int) (ncp - PyString_AsString (str));
            if (len == 0) {
                rv = PyString_FromStringAndSize ("", 0);
                Py_DECREF (str);
                str = rv;
            }
            else if (_PyString_Resize (&str, len) < 0)
                goto exit;
            rv = Py_BuildValue ("(O(iO))", str, d, samps);
            Py_DECREF (samps);
            Py_DECREF (str);
            goto exit;
        }
        for (chan = 0; chan < nchannels; chan++) {
            prev_i[chan] = cur_i[chan];
            if (size == 1)
                cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
            else if (size == 2)
                cur_i[chan] = (int) *SHORTP (cp, 0);
            else if (size == 4)
                cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
            cp += size;
            cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
        }
        len--;
        d += outrate;
    }
    while (d >= 0) {
        for (chan = 0; chan < nchannels; chan++) {
            cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
            if (size == 1)
                *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
            else if (size == 2)
                *SHORTP (ncp, 0) = (short) (cur_o);
            else if (size == 4)
                *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
            ncp += size;
        }
        d -= inrate;
    }
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1166" endline="1210">
{
    if (len == 0) {
        samps = PyTuple_New (nchannels);
        if (samps == NULL)
            goto exit;
        for (chan = 0; chan < nchannels; chan++)
            PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
        if (PyErr_Occurred ())
            goto exit;
        len = (int) (ncp - PyString_AsString (str));
        if (len == 0) {
            rv = PyString_FromStringAndSize ("", 0);
            Py_DECREF (str);
            str = rv;
        }
        else if (_PyString_Resize (&str, len) < 0)
            goto exit;
        rv = Py_BuildValue ("(O(iO))", str, d, samps);
        Py_DECREF (samps);
        Py_DECREF (str);
        goto exit;
    }
    for (chan = 0; chan < nchannels; chan++) {
        prev_i[chan] = cur_i[chan];
        if (size == 1)
            cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
        else if (size == 2)
            cur_i[chan] = (int) *SHORTP (cp, 0);
        else if (size == 4)
            cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
        cp += size;
        cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
    }
    len--;
    d += outrate;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1167" endline="1192">
{
    samps = PyTuple_New (nchannels);
    if (samps == NULL)
        goto exit;
    for (chan = 0; chan < nchannels; chan++)
        PyTuple_SetItem (samps, chan, Py_BuildValue ("(ii)", prev_i[chan], cur_i[chan]));
    if (PyErr_Occurred ())
        goto exit;
    len = (int) (ncp - PyString_AsString (str));
    if (len == 0) {
        rv = PyString_FromStringAndSize ("", 0);
        Py_DECREF (str);
        str = rv;
    }
    else if (_PyString_Resize (&str, len) < 0)
        goto exit;
    rv = Py_BuildValue ("(O(iO))", str, d, samps);
    Py_DECREF (samps);
    Py_DECREF (str);
    goto exit;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1181" endline="1186">
{
    rv = PyString_FromStringAndSize ("", 0);
    Py_DECREF (str);
    str = rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1193" endline="1207">
{
    prev_i[chan] = cur_i[chan];
    if (size == 1)
        cur_i[chan] = ((int) *CHARP (cp, 0)) << 8;
    else if (size == 2)
        cur_i[chan] = (int) *SHORTP (cp, 0);
    else if (size == 4)
        cur_i[chan] = ((int) *LONGP (cp, 0)) >> 16;
    cp += size;
    cur_i[chan] = (weightA * cur_i[chan] + weightB * prev_i[chan]) / (weightA + weightB);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1211" endline="1225">
{
    for (chan = 0; chan < nchannels; chan++) {
        cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
        if (size == 1)
            *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
        else if (size == 2)
            *SHORTP (ncp, 0) = (short) (cur_o);
        else if (size == 4)
            *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
        ncp += size;
    }
    d -= inrate;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1212" endline="1223">
{
    cur_o = (prev_i[chan] * d + cur_i[chan] * (outrate - d)) / outrate;
    if (size == 1)
        *CHARP (ncp, 0) = (signed char) (cur_o >> 8);
    else if (size == 2)
        *SHORTP (ncp, 0) = (short) (cur_o);
    else if (size == 4)
        *LONGP (ncp, 0) = (Py_Int32) (cur_o << 16);
    ncp += size;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1237" endline="1266">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2ulaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_14linear2ulaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1248" endline="1251">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1258" endline="1264">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    *ncp++ = st_14linear2ulaw (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1270" endline="1301">
{
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:ulaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_ulaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1282" endline="1285">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1292" endline="1299">
{
    cval = *cp++;
    val = st_ulaw2linear16 (cval);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1305" endline="1334">
{
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2alaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_linear2alaw (val);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1316" endline="1319">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1326" endline="1332">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    *ncp++ = st_linear2alaw (val);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1338" endline="1369">
{
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:alaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_alaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1350" endline="1353">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1360" endline="1367">
{
    cval = *cp++;
    val = st_alaw2linear16 (cval);
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (val >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (val);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (val << 16);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1373" endline="1478">
{
    signed char *cp;
    signed char *ncp;
    int len, size, val = 0, step, valpred, delta, index, sign, vpdiff, diff;
    PyObject *rv, *state, *str;
    int i, outputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:lin2adpcm", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    str = PyString_FromStringAndSize (NULL, len / (size * 2));
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    step = stepsizeTable[index];
    bufferstep = 1;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        diff = val - valpred;
        sign = (diff < 0) ? 8 : 0;
        if (sign)
            diff = (-diff);
        delta = 0;
        vpdiff = (step >> 3);
        if (diff >= step) {
            delta = 4;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 2;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 1;
            vpdiff += step;
        }
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        delta |= sign;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        step = stepsizeTable[index];
        if (bufferstep) {
            outputbuffer = (delta << 4) & 0xf0;
        }
        else {
            *ncp++ = (delta & 0x0f) | outputbuffer;
        }
        bufferstep = !bufferstep;
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1386" endline="1389">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1397" endline="1402">
{
    valpred = 0;
    step = 7;
    index = 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1408" endline="1474">
{
    if (size == 1)
        val = ((int) *CHARP (cp, i)) << 8;
    else if (size == 2)
        val = (int) *SHORTP (cp, i);
    else if (size == 4)
        val = ((int) *LONGP (cp, i)) >> 16;
    diff = val - valpred;
    sign = (diff < 0) ? 8 : 0;
    if (sign)
        diff = (-diff);
    delta = 0;
    vpdiff = (step >> 3);
    if (diff >= step) {
        delta = 4;
        diff -= step;
        vpdiff += step;
    }
    step >>= 1;
    if (diff >= step) {
        delta |= 2;
        diff -= step;
        vpdiff += step;
    }
    step >>= 1;
    if (diff >= step) {
        delta |= 1;
        vpdiff += step;
    }
    if (sign)
        valpred -= vpdiff;
    else
        valpred += vpdiff;
    if (valpred > 32767)
        valpred = 32767;
    else if (valpred < -32768)
        valpred = -32768;
    delta |= sign;
    index += indexTable[delta];
    if (index < 0)
        index = 0;
    if (index > 88)
        index = 88;
    step = stepsizeTable[index];
    if (bufferstep) {
        outputbuffer = (delta << 4) & 0xf0;
    }
    else {
        *ncp++ = (delta & 0x0f) | outputbuffer;
    }
    bufferstep = !bufferstep;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1430" endline="1434">
{
    delta = 4;
    diff -= step;
    vpdiff += step;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1436" endline="1440">
{
    delta |= 2;
    diff -= step;
    vpdiff += step;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1442" endline="1445">
{
    delta |= 1;
    vpdiff += step;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1468" endline="1470">
{
    outputbuffer = (delta << 4) & 0xf0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1470" endline="1472">
{
    *ncp++ = (delta & 0x0f) | outputbuffer;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1482" endline="1568">
{
    signed char *cp;
    signed char *ncp;
    int len, size, valpred, step, delta, index, sign, vpdiff;
    PyObject *rv, *str, *state;
    int i, inputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:adpcm2lin", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    str = PyString_FromStringAndSize (NULL, len *size * 2);
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    step = stepsizeTable[index];
    bufferstep = 0;
    for (i = 0; i < len * size * 2; i += size) {
        if (bufferstep) {
            delta = inputbuffer & 0xf;
        }
        else {
            inputbuffer = *cp++;
            delta = (inputbuffer >> 4) & 0xf;
        }
        bufferstep = !bufferstep;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        sign = delta & 8;
        delta = delta & 7;
        vpdiff = step >> 3;
        if (delta & 4)
            vpdiff += step;
        if (delta & 2)
            vpdiff += step >> 1;
        if (delta & 1)
            vpdiff += step >> 2;
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        step = stepsizeTable[index];
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (valpred >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (valpred);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1493" endline="1496">
{
    PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
    return 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1499" endline="1504">
{
    valpred = 0;
    step = 7;
    index = 0;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1515" endline="1563">
{
    if (bufferstep) {
        delta = inputbuffer & 0xf;
    }
    else {
        inputbuffer = *cp++;
        delta = (inputbuffer >> 4) & 0xf;
    }
    bufferstep = !bufferstep;
    index += indexTable[delta];
    if (index < 0)
        index = 0;
    if (index > 88)
        index = 88;
    sign = delta & 8;
    delta = delta & 7;
    vpdiff = step >> 3;
    if (delta & 4)
        vpdiff += step;
    if (delta & 2)
        vpdiff += step >> 1;
    if (delta & 1)
        vpdiff += step >> 2;
    if (sign)
        valpred -= vpdiff;
    else
        valpred += vpdiff;
    if (valpred > 32767)
        valpred = 32767;
    else if (valpred < -32768)
        valpred = -32768;
    step = stepsizeTable[index];
    if (size == 1)
        *CHARP (ncp, i) = (signed char) (valpred >> 8);
    else if (size == 2)
        *SHORTP (ncp, i) = (short) (valpred);
    else if (size == 4)
        *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1517" endline="1519">
{
    delta = inputbuffer & 0xf;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1519" endline="1522">
{
    inputbuffer = *cp++;
    delta = (inputbuffer >> 4) & 0xf;
}
</source>
<source file="examples2/python//smallPython/audioop.c.ifdefed" startline="1601" endline="1612">
{
    PyObject *m, *d;
    m = Py_InitModule ("audioop", audioop_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (d == NULL)
        return;
    AudioopError = PyErr_NewException ("audioop.error", NULL, NULL);
    if (AudioopError != NULL)
        PyDict_SetItemString (d, "error", AudioopError);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="20" endline="27">
{
    int fd = PyObject_AsFileDescriptor (object);
    if (fd < 0)
        return 0;
    *target = fd;
    return 1;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="34" endline="77">
{
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    char buf [1024];
    if (PyArg_ParseTuple (args, "O&is#:fcntl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > sizeof buf) {
            PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&i|i;fcntl requires a file or file descriptor," " an integer and optionally a third integer or a string", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="44" endline="59">
{
    if (len > sizeof buf) {
        PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
        return NULL;
    }
    memcpy (buf, str, len);
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, code, buf);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="45" endline="49">
{
    PyErr_SetString (PyExc_ValueError, "fcntl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="54" endline="57">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="66" endline="68">
{
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="72" endline="75">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="97" endline="203">
{
    int fd;
    int code;
    int arg;
    int ret;
    char *str;
    Py_ssize_t len;
    int mutate_arg = 1;
    char buf [IOCTL_BUFSZ + 1];
    if (PyArg_ParseTuple (args, "O&Iw#|i:ioctl", conv_descriptor, &fd, &code, &str, &len, &mutate_arg)) {
        char *arg;
        if (mutate_arg) {
            if (len <= IOCTL_BUFSZ) {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
            else {
                arg = str;
            }
        }
        else {
            if (len > IOCTL_BUFSZ) {
                PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
                return NULL;
            }
            else {
                memcpy (buf, str, len);
                buf[len] = '\0';
                arg = buf;
            }
        }
        if (buf == arg) {
            Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
            Py_END_ALLOW_THREADS
        }
        else {
            ret = ioctl (fd, code, arg);
        }
        if (mutate_arg && (len < IOCTL_BUFSZ)) {
            memcpy (str, buf, len);
        }
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        if (mutate_arg) {
            return PyInt_FromLong (ret);
        }
        else {
            return PyString_FromStringAndSize (buf, len);
        }
    }
    PyErr_Clear ();
    if (PyArg_ParseTuple (args, "O&Is#:ioctl", conv_descriptor, &fd, &code, &str, &len)) {
        if (len > IOCTL_BUFSZ) {
            PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
            return NULL;
        }
        memcpy (buf, str, len);
        buf[len] = '\0';
        Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, buf);
        Py_END_ALLOW_THREADS
        if (ret < 0) {
            PyErr_SetFromErrno (PyExc_IOError);
            return NULL;
        }
        return PyString_FromStringAndSize (buf, len);
    }
    PyErr_Clear ();
    arg = 0;
    if (!PyArg_ParseTuple (args, "O&I|i;ioctl requires a file or file descriptor," " an integer and optionally an integer or buffer argument", conv_descriptor, &fd, &code, &arg)) {
        return NULL;
    }
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyInt_FromLong ((long) ret);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="114" endline="160">
{
    char *arg;
    if (mutate_arg) {
        if (len <= IOCTL_BUFSZ) {
            memcpy (buf, str, len);
            buf[len] = '\0';
            arg = buf;
        }
        else {
            arg = str;
        }
    }
    else {
        if (len > IOCTL_BUFSZ) {
            PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
            return NULL;
        }
        else {
            memcpy (buf, str, len);
            buf[len] = '\0';
            arg = buf;
        }
    }
    if (buf == arg) {
        Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
        Py_END_ALLOW_THREADS
    }
    else {
        ret = ioctl (fd, code, arg);
    }
    if (mutate_arg && (len < IOCTL_BUFSZ)) {
        memcpy (str, buf, len);
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    if (mutate_arg) {
        return PyInt_FromLong (ret);
    }
    else {
        return PyString_FromStringAndSize (buf, len);
    }
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="117" endline="126">
{
    if (len <= IOCTL_BUFSZ) {
        memcpy (buf, str, len);
        buf[len] = '\0';
        arg = buf;
    }
    else {
        arg = str;
    }
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="118" endline="122">
{
    memcpy (buf, str, len);
    buf[len] = '\0';
    arg = buf;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="123" endline="125">
{
    arg = str;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="127" endline="138">
{
    if (len > IOCTL_BUFSZ) {
        PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
        return NULL;
    }
    else {
        memcpy (buf, str, len);
        buf[len] = '\0';
        arg = buf;
    }
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="128" endline="132">
{
    PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="133" endline="137">
{
    memcpy (buf, str, len);
    buf[len] = '\0';
    arg = buf;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="139" endline="143">
{
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, arg);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="144" endline="146">
{
    ret = ioctl (fd, code, arg);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="147" endline="149">
{
    memcpy (str, buf, len);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="150" endline="153">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="154" endline="156">
{
    return PyInt_FromLong (ret);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="157" endline="159">
{
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="164" endline="180">
{
    if (len > IOCTL_BUFSZ) {
        PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
        return NULL;
    }
    memcpy (buf, str, len);
    buf[len] = '\0';
    Py_BEGIN_ALLOW_THREADS ret = ioctl (fd, code, buf);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    return PyString_FromStringAndSize (buf, len);
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="165" endline="169">
{
    PyErr_SetString (PyExc_ValueError, "ioctl string arg too long");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="175" endline="178">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="187" endline="189">
{
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="197" endline="200">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="241" endline="287">
{
    int fd;
    int code;
    int ret;
    if (!PyArg_ParseTuple (args, "O&i:flock", conv_descriptor, &fd, &code))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
            return NULL;
        }
        l.l_whence = l.l_start = l.l_len = 0;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="262" endline="279">
{
    struct flock l;
    if (code == LOCK_UN)
        l.l_type = F_UNLCK;
    else if (code & LOCK_SH)
        l.l_type = F_RDLCK;
    else if (code & LOCK_EX)
        l.l_type = F_WRLCK;
    else {
        PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
        return NULL;
    }
    l.l_whence = l.l_start = l.l_len = 0;
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="270" endline="274">
{
    PyErr_SetString (PyExc_ValueError, "unrecognized flock argument");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="281" endline="284">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="300" endline="368">
{
    int fd, code, ret, whence = 0;
    PyObject *lenobj = NULL, *startobj = NULL;
    if (!PyArg_ParseTuple (args, "O&i|OOi:lockf", conv_descriptor, &fd, &code, &lenobj, &startobj, &whence))
        return NULL;
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
            return NULL;
        }
        l.l_start = l.l_len = 0;
        if (startobj != NULL) {
            l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        if (lenobj != NULL) {
            l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
            if (PyErr_Occurred ())
                return NULL;
        }
        l.l_whence = whence;
        Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
        Py_END_ALLOW_THREADS
    }
    if (ret < 0) {
        PyErr_SetFromErrno (PyExc_IOError);
        return NULL;
    }
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="320" endline="360">
{
    struct flock l;
    if (code == LOCK_UN)
        l.l_type = F_UNLCK;
    else if (code & LOCK_SH)
        l.l_type = F_RDLCK;
    else if (code & LOCK_EX)
        l.l_type = F_WRLCK;
    else {
        PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
        return NULL;
    }
    l.l_start = l.l_len = 0;
    if (startobj != NULL) {
        l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
        if (PyErr_Occurred ())
            return NULL;
    }
    if (lenobj != NULL) {
        l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
        if (PyErr_Occurred ())
            return NULL;
    }
    l.l_whence = whence;
    Py_BEGIN_ALLOW_THREADS ret = fcntl (fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
    Py_END_ALLOW_THREADS
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="328" endline="332">
{
    PyErr_SetString (PyExc_ValueError, "unrecognized lockf argument");
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="334" endline="344">
{
    l.l_start = PyLong_Check (startobj) ? PyLong_AsLongLong (startobj) : PyInt_AsLong (startobj);
    if (PyErr_Occurred ())
        return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="345" endline="355">
{
    l.l_len = PyLong_Check (lenobj) ? PyLong_AsLongLong (lenobj) : PyInt_AsLong (lenobj);
    if (PyErr_Occurred ())
        return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="361" endline="364">
{
    PyErr_SetFromErrno (PyExc_IOError);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="416" endline="423">
{
    PyObject *v = PyInt_FromLong (value);
    if (!v || PyDict_SetItemString (d, symbol, v) < 0)
        return -1;
    Py_DECREF (v);
    return 0;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="429" endline="588">
{
    if (ins (d, "LOCK_SH", (long) LOCK_SH))
        return -1;
    if (ins (d, "LOCK_EX", (long) LOCK_EX))
        return -1;
    if (ins (d, "LOCK_NB", (long) LOCK_NB))
        return -1;
    if (ins (d, "LOCK_UN", (long) LOCK_UN))
        return -1;
    return 0;
}
</source>
<source file="examples2/python//smallPython/fcntlmodule.c.ifdefed" startline="592" endline="603">
{
    PyObject *m, *d;
    m = Py_InitModule3 ("fcntl", fcntl_methods, module_doc);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    all_ins (d);
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="104" endline="110">
{
    fpe_reset (sigfpe_handler);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="113" endline="257">
{
    fputs ("Operation not implemented\n", stderr);
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="260" endline="277">
{
    fputs ("Operation not implemented\n", stderr);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="280" endline="287">
{
    fpe_reset (sigfpe_handler);
    if (PyFPE_counter) {
        longjmp (PyFPE_jbuf, 1);
    }
    else {
        Py_FatalError ("Unprotected floating point exception");
    }
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="282" endline="284">
{
    longjmp (PyFPE_jbuf, 1);
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="284" endline="286">
{
    Py_FatalError ("Unprotected floating point exception");
}
</source>
<source file="examples2/python//smallPython/fpectlmodule.c.ifdefed" startline="290" endline="299">
{
    PyObject *m, *d;
    m = Py_InitModule ("fpectl", fpectl_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpectl.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="62" endline="99">
{
    double r;
    fprintf (stderr, "overflow");
    r = overflow (1.e160);
    printerr (r);
    fprintf (stderr, "\ndiv by 0");
    r = db0 (0.0);
    printerr (r);
    fprintf (stderr, "\nnested outer");
    r = nest1 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested inner");
    r = nest1 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\ntrailing outer");
    r = nest1 (2, 2.0);
    printerr (r);
    fprintf (stderr, "\nnested prior");
    r = nest2 (0, 0.0);
    printerr (r);
    fprintf (stderr, "\nnested interior");
    r = nest2 (1, 1.0);
    printerr (r);
    fprintf (stderr, "\nnested trailing");
    r = nest2 (2, 2.0);
    printerr (r);
    Py_INCREF (Py_None);
    return Py_None;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="102" endline="110">
{
    if (r == 3.1416) {
        fprintf (stderr, "\tPASS\n");
        PyErr_Print ();
    }
    else {
        fprintf (stderr, "\tFAIL\n");
    }
    PyErr_Clear ();
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="103" endline="106">
{
    fprintf (stderr, "\tPASS\n");
    PyErr_Print ();
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="106" endline="108">
{
    fprintf (stderr, "\tFAIL\n");
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="113" endline="130">
{
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, outer zone", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        PyFPE_START_PROTECT ("Division by zero, inner zone", return 3.1416)
        a = 1./ (1.- x);
        PyFPE_END_PROTECT (a)
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="117" endline="119">
{
    a = 1./ x;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="119" endline="124">
{
    PyFPE_START_PROTECT ("Division by zero, inner zone", return 3.1416)
    a = 1./ (1.- x);
    PyFPE_END_PROTECT (a)
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="124" endline="126">
{
    a = 1./ (2.- x);
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="133" endline="145">
{
    double a = 1.0;
    PyFPE_START_PROTECT ("Division by zero, prior error", return 3.1416)
    if (i == 0) {
        a = 1./ x;
    }
    else if (i == 1) {
        a = nest3 (x);
    }
    else if (i == 2) {
        a = 1./ (2.- x);
    }
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="136" endline="138">
{
    a = 1./ x;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="138" endline="140">
{
    a = nest3 (x);
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="140" endline="142">
{
    a = 1./ (2.- x);
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="148" endline="155">
{
    double result;
    PyFPE_START_PROTECT ("Division by zero, nest3 error", return 3.1416)
    result = 1./ (1.- x);
    PyFPE_END_PROTECT (result)
    return result;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="158" endline="164">
{
    double a;
    PyFPE_START_PROTECT ("Division by zero", return 3.1416)
    a = 1./ x;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="167" endline="173">
{
    double a;
    PyFPE_START_PROTECT ("Overflow", return 3.1416)
    a = b * b;
    PyFPE_END_PROTECT (a)
    return a;
}
</source>
<source file="examples2/python//smallPython/fpetestmodule.c.ifdefed" startline="176" endline="186">
{
    PyObject *m, *d;
    m = Py_InitModule ("fpetest", fpetest_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpetest.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="37" endline="84">
{
    int setIndex = 0;
    PyObject *v = PyStructSequence_New (&StructGrpType), *w;
    char **member;
    if (v == NULL)
        return NULL;
    if ((w = PyList_New (0)) == NULL) {
        Py_DECREF (v);
        return NULL;
    }
    for (member = p->gr_mem; *member != NULL; member++) {
        PyObject *x = PyString_FromString (*member);
        if (x == NULL || PyList_Append (w, x) != 0) {
            Py_XDECREF (x);
            Py_DECREF (w);
            Py_DECREF (v);
            return NULL;
        }
        Py_DECREF (x);
    }
    SET (setIndex ++, PyString_FromString (p -> gr_name));
    if (p->gr_passwd)
        SET (setIndex++, PyString_FromString (p->gr_passwd));
    else {
        SET (setIndex ++, Py_None);
        Py_INCREF (Py_None);
    }
    SET (setIndex ++, PyInt_FromLong ((long) p -> gr_gid));
    SET (setIndex ++, w);
    if (PyErr_Occurred ()) {
        Py_DECREF (v);
        Py_DECREF (w);
        return NULL;
    }
    return v;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="45" endline="48">
{
    Py_DECREF (v);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="49" endline="58">
{
    PyObject *x = PyString_FromString (*member);
    if (x == NULL || PyList_Append (w, x) != 0) {
        Py_XDECREF (x);
        Py_DECREF (w);
        Py_DECREF (v);
        return NULL;
    }
    Py_DECREF (x);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="51" endline="56">
{
    Py_XDECREF (x);
    Py_DECREF (w);
    Py_DECREF (v);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="68" endline="71">
{
    SET (setIndex ++, Py_None);
    Py_INCREF (Py_None);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="77" endline="81">
{
    Py_DECREF (v);
    Py_DECREF (w);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="88" endline="104">
{
    PyObject *py_int_id;
    unsigned int gid;
    struct group *p;
    py_int_id = PyNumber_Int (pyo_id);
    if (!py_int_id)
        return NULL;
    gid = PyInt_AS_LONG (py_int_id);
    Py_DECREF (py_int_id);
    if ((p = getgrgid (gid)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
        return NULL;
    }
    return mkgrent (p);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="99" endline="102">
{
    PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="108" endline="126">
{
    PyObject *py_str_name;
    char *name;
    struct group *p;
    py_str_name = PyObject_Str (pyo_name);
    if (!py_str_name)
        return NULL;
    name = PyString_AS_STRING (py_str_name);
    if ((p = getgrnam (name)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
        Py_DECREF (py_str_name);
        return NULL;
    }
    Py_DECREF (py_str_name);
    return mkgrent (p);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="118" endline="122">
{
    PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
    Py_DECREF (py_str_name);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="130" endline="148">
{
    PyObject *d;
    struct group *p;
    if ((d = PyList_New (0)) == NULL)
        return NULL;
    setgrent ();
    while ((p = getgrent ()) != NULL) {
        PyObject *v = mkgrent (p);
        if (v == NULL || PyList_Append (d, v) != 0) {
            Py_XDECREF (v);
            Py_DECREF (d);
            return NULL;
        }
        Py_DECREF (v);
    }
    endgrent ();
    return d;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="137" endline="145">
{
    PyObject *v = mkgrent (p);
    if (v == NULL || PyList_Append (d, v) != 0) {
        Py_XDECREF (v);
        Py_DECREF (d);
        return NULL;
    }
    Py_DECREF (v);
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="139" endline="143">
{
    Py_XDECREF (v);
    Py_DECREF (d);
    return NULL;
}
</source>
<source file="examples2/python//smallPython/grpmodule.c.ifdefed" startline="184" endline="194">
{
    PyObject *m, *d;
    m = Py_InitModule3 ("grp", grp_methods, grp__doc__);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (!initialized)
        PyStructSequence_InitType (&StructGrpType, &struct_group_type_desc);
    PyDict_SetItemString (d, "struct_group", (PyObject *) & StructGrpType);
    initialized = 1;
}
</source>
