<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="simcad.xsl"?>
<SimCad version="SimCad 2.2">
<DetectionTimeStamp>2013-11-19 13:09:42.143</DetectionTimeStamp>
<SearchInput>n/a</SearchInput>
<SearchTarget>input/python/</SearchTarget>
<SourceFragmentType>function</SourceFragmentType>
<SourceTransformation>generous</SourceTransformation>
<CloneType>Type-1, Type-2, Type-3</CloneType>
<CloneGroupingType>group</CloneGroupingType>
<SourceFragmentTotal>74</SourceFragmentTotal>
<CloneFragmentTotal>35</CloneFragmentTotal>
<CloneSetTotal>10</CloneSetTotal>
<Clones fragmentType="function" cloneSetType="group" nfragments="35" ngroups="10">
<CloneGroup groupid="1" nfragments="2" type="Type-3">
<CloneFragment file="/fpectlmodule.c.ifdefed" startline="103" endline="110" pcid="57"><![CDATA[
static PyObject *turnon_sigfpe (PyObject *self, PyObject *args) {
    fpe_reset (sigfpe_handler);
    Py_INCREF (Py_None);
    return Py_None;
}
]]></CloneFragment>
<CloneFragment file="/fpectlmodule.c.ifdefed" startline="259" endline="277" pcid="58"><![CDATA[
static PyObject *turnoff_sigfpe (PyObject *self, PyObject *args) {
    fputs ("Operation not implemented\n", stderr);
    Py_INCREF (Py_None);
    return Py_None;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="2" nfragments="3" type="Type-3">
<CloneFragment file="/fpectlmodule.c.ifdefed" startline="289" endline="299" pcid="60"><![CDATA[
PyMODINIT_FUNC initfpectl (void) {
    PyObject *m, *d;
    m = Py_InitModule ("fpectl", fpectl_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpectl.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
]]></CloneFragment>
<CloneFragment file="/fpetestmodule.c.ifdefed" startline="175" endline="186" pcid="68"><![CDATA[
PyMODINIT_FUNC initfpetest (void) {
    PyObject *m, *d;
    m = Py_InitModule ("fpetest", fpetest_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    fpe_error = PyErr_NewException ("fpetest.error", NULL, NULL);
    if (fpe_error != NULL)
        PyDict_SetItemString (d, "error", fpe_error);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1599" endline="1612" pcid="30"><![CDATA[
PyMODINIT_FUNC initaudioop (void) {
    PyObject *m, *d;
    m = Py_InitModule ("audioop", audioop_methods);
    if (m == NULL)
        return;
    d = PyModule_GetDict (m);
    if (d == NULL)
        return;
    AudioopError = PyErr_NewException ("audioop.error", NULL, NULL);
    if (AudioopError != NULL)
        PyDict_SetItemString (d, "error", AudioopError);
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="3" nfragments="2" type="Type-2">
<CloneFragment file="/cmathmodule.c.ifdefed" startline="39" endline="47" pcid="31"><![CDATA[
static Py_complex c_acosh (Py_complex x) {
    Py_complex z;
    z = c_sqrt (c_half);
    z = c_log (c_prod (z, c_sum (c_sqrt (c_sum (x, c_one)), c_sqrt (c_diff (x, c_one)))));
    return c_sum (z, z);
}
]]></CloneFragment>
<CloneFragment file="/cmathmodule.c.ifdefed" startline="72" endline="80" pcid="33"><![CDATA[
static Py_complex c_asinh (Py_complex x) {
    Py_complex z;
    z = c_sqrt (c_half);
    z = c_log (c_prod (z, c_sum (c_sqrt (c_sum (x, c_i)), c_sqrt (c_diff (x, c_i)))));
    return c_sum (z, z);
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="4" nfragments="2" type="Type-3">
<CloneFragment file="/cmathmodule.c.ifdefed" startline="112" endline="119" pcid="34"><![CDATA[
static Py_complex c_cos (Py_complex x) {
    Py_complex r;
    r.real = cos (x.real) * cosh (x.imag);
    r.imag = -sin (x.real) * sinh (x.imag);
    return r;
}
]]></CloneFragment>
<CloneFragment file="/cmathmodule.c.ifdefed" startline="196" endline="203" pcid="40"><![CDATA[
static Py_complex c_sin (Py_complex x) {
    Py_complex r;
    r.real = sin (x.real) * cosh (x.imag);
    r.imag = cos (x.real) * sinh (x.imag);
    return r;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="5" nfragments="2" type="Type-2">
<CloneFragment file="/cmathmodule.c.ifdefed" startline="127" endline="134" pcid="35"><![CDATA[
static Py_complex c_cosh (Py_complex x) {
    Py_complex r;
    r.real = cos (x.imag) * cosh (x.real);
    r.imag = sin (x.imag) * sinh (x.real);
    return r;
}
]]></CloneFragment>
<CloneFragment file="/cmathmodule.c.ifdefed" startline="211" endline="218" pcid="41"><![CDATA[
static Py_complex c_sinh (Py_complex x) {
    Py_complex r;
    r.real = cos (x.imag) * sinh (x.real);
    r.imag = sin (x.imag) * cosh (x.real);
    return r;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="6" nfragments="2" type="Type-2">
<CloneFragment file="/cmathmodule.c.ifdefed" startline="258" endline="277" pcid="43"><![CDATA[
static Py_complex c_tan (Py_complex x) {
    Py_complex r;
    double sr, cr, shi, chi;
    double rs, is, rc, ic;
    double d;
    sr = sin (x.real);
    cr = cos (x.real);
    shi = sinh (x.imag);
    chi = cosh (x.imag);
    rs = sr * chi;
    is = cr * shi;
    rc = cr * chi;
    ic = -sr * shi;
    d = rc * rc + ic * ic;
    r.real = (rs * rc + is * ic) / d;
    r.imag = (is * rc - rs * ic) / d;
    return r;
}
]]></CloneFragment>
<CloneFragment file="/cmathmodule.c.ifdefed" startline="285" endline="304" pcid="44"><![CDATA[
static Py_complex c_tanh (Py_complex x) {
    Py_complex r;
    double si, ci, shr, chr;
    double rs, is, rc, ic;
    double d;
    si = sin (x.imag);
    ci = cos (x.imag);
    shr = sinh (x.real);
    chr = cosh (x.real);
    rs = ci * shr;
    is = si * chr;
    rc = ci * chr;
    ic = si * shr;
    d = rc * rc + ic * ic;
    r.real = (rs * rc + is * ic) / d;
    r.imag = (is * rc - rs * ic) / d;
    return r;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="7" nfragments="3" type="Type-3">
<CloneFragment file="/grpmodule.c.ifdefed" startline="86" endline="104" pcid="70"><![CDATA[
static PyObject *grp_getgrgid (PyObject *self, PyObject *pyo_id) {
    PyObject *py_int_id;
    unsigned int gid;
    struct group *p;
    py_int_id = PyNumber_Int (pyo_id);
    if (!py_int_id)
        return NULL;
    gid = PyInt_AS_LONG (py_int_id);
    Py_DECREF (py_int_id);
    if ((p = getgrgid (gid)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrgid(): gid not found: %d", gid);
        return NULL;
    }
    return mkgrent (p);
}
]]></CloneFragment>
<CloneFragment file="/grpmodule.c.ifdefed" startline="106" endline="126" pcid="71"><![CDATA[
static PyObject *grp_getgrnam (PyObject *self, PyObject *pyo_name) {
    PyObject *py_str_name;
    char *name;
    struct group *p;
    py_str_name = PyObject_Str (pyo_name);
    if (!py_str_name)
        return NULL;
    name = PyString_AS_STRING (py_str_name);
    if ((p = getgrnam (name)) == NULL) {
        PyErr_Format (PyExc_KeyError, "getgrnam(): name not found: %s", name);
        Py_DECREF (py_str_name);
        return NULL;
    }
    Py_DECREF (py_str_name);
    return mkgrent (p);
}
]]></CloneFragment>
<CloneFragment file="/grpmodule.c.ifdefed" startline="128" endline="148" pcid="72"><![CDATA[
static PyObject *grp_getgrall (PyObject *self, PyObject *ignore) {
    PyObject *d;
    struct group *p;
    if ((d = PyList_New (0)) == NULL)
        return NULL;
    setgrent ();
    while ((p = getgrent ()) != NULL) {
        PyObject *v = mkgrent (p);
        if (v == NULL || PyList_Append (d, v) != 0) {
            Py_XDECREF (v);
            Py_DECREF (d);
            return NULL;
        }
        Py_DECREF (v);
    }
    endgrent ();
    return d;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="8" nfragments="4" type="Type-3">
<CloneFragment file="/audioop.c.ifdefed" startline="298" endline="319" pcid="3"><![CDATA[
static PyObject *audioop_getsample (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    if (!PyArg_ParseTuple (args, "s#ii:getsample", &cp, &len, &size, &i))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (i < 0 || i >= len / size) {
        PyErr_SetString (AudioopError, "Index out of range");
        return 0;
    }
    if (size == 1)
        val = (int) *CHARP (cp, i);
    else if (size == 2)
        val = (int) *SHORTP (cp, i *2);
    else if (size == 4)
        val = (int) *LONGP (cp, i *4);
    return PyInt_FromLong (val);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="321" endline="343" pcid="4"><![CDATA[
static PyObject *audioop_max (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    int max = 0;
    if (!PyArg_ParseTuple (args, "s#i:max", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val < 0)
            val = (-val);
        if (val > max)
            max = val;
    }
    return PyInt_FromLong (max);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="345" endline="367" pcid="5"><![CDATA[
static PyObject *audioop_minmax (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    int min = 0x7fffffff, max = -0x7fffffff;
    if (!PyArg_ParseTuple (args, "s#i:minmax", &cp, &len, &size))
        return NULL;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return NULL;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (val > max)
            max = val;
        if (val < min)
            min = val;
    }
    return Py_BuildValue ("(ii)", min, max);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="369" endline="394" pcid="6"><![CDATA[
static PyObject *audioop_avg (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0;
    int i;
    double avg = 0.0;
    if (!PyArg_ParseTuple (args, "s#i:avg", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        avg += val;
    }
    if (len == 0)
        val = 0;
    else
        val = (int) (avg / (double) (len / size));
    return PyInt_FromLong (val);
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="9" nfragments="13" type="Type-3">
<CloneFragment file="/audioop.c.ifdefed" startline="600" endline="655" pcid="12"><![CDATA[
static PyObject *audioop_avgpp (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    double avg = 0.0;
    int diff, prevdiff, extremediff, nextreme = 0;
    if (!PyArg_ParseTuple (args, "s#i:avgpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                avg += extremediff;
                nextreme++;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    if (nextreme == 0)
        val = 0;
    else
        val = (int) (avg / (double) nextreme);
    return PyInt_FromLong (val);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="657" endline="708" pcid="13"><![CDATA[
static PyObject *audioop_maxpp (PyObject *self, PyObject *args) {
    signed char *cp;
    int len, size, val = 0, prevval = 0, prevextremevalid = 0, prevextreme = 0;
    int i;
    int max = 0;
    int diff, prevdiff, extremediff;
    if (!PyArg_ParseTuple (args, "s#i:maxpp", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (size == 1)
        prevval = (int) *CHARP (cp, 0);
    else if (size == 2)
        prevval = (int) *SHORTP (cp, 0);
    else if (size == 4)
        prevval = (int) *LONGP (cp, 0);
    if (size == 1)
        val = (int) *CHARP (cp, size);
    else if (size == 2)
        val = (int) *SHORTP (cp, size);
    else if (size == 4)
        val = (int) *LONGP (cp, size);
    prevdiff = val - prevval;
    for (i = size; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        diff = val - prevval;
        if (diff * prevdiff < 0) {
            if (prevextremevalid) {
                extremediff = prevval - prevextreme;
                if (extremediff < 0)
                    extremediff = -extremediff;
                if (extremediff > max)
                    max = extremediff;
            }
            prevextremevalid = 1;
            prevextreme = prevval;
        }
        prevval = val;
        if (diff != 0)
            prevdiff = diff;
    }
    return PyInt_FromLong (max);
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="823" endline="874" pcid="17"><![CDATA[
static PyObject *audioop_tostereo (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val1, val2, val = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tostereo", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * fac1;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        fval = (double) val * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val2 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i *2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i *2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i *2) = (Py_Int32) val1;
        if (size == 1)
            *CHARP (ncp, i *2 + 1) = (signed char) val2;
        else if (size == 2)
            *SHORTP (ncp, i *2 + 2) = (short) val2;
        else if (size == 4)
            *LONGP (ncp, i *2 + 4) = (Py_Int32) val2;
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="737" endline="776" pcid="15"><![CDATA[
static PyObject *audioop_mul (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val = 0;
    double factor, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#id:mul", &cp, &len, &size, &factor))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        fval = (double) val * factor;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val = (int) fval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) val;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) val;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) val;
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="778" endline="821" pcid="16"><![CDATA[
static PyObject *audioop_tomono (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val1 = 0, val2 = 0;
    double fac1, fac2, fval, maxval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#idd:tomono", &cp, &len, &size, &fac1, &fac2))
        return 0;
    if (size == 1)
        maxval = (double) 0x7f;
    else if (size == 2)
        maxval = (double) 0x7fff;
    else if (size == 4)
        maxval = (double) 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / 2);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size * 2) {
        if (size == 1)
            val1 = (int) *CHARP (cp, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp, i);
        if (size == 1)
            val2 = (int) *CHARP (cp, i +1);
        else if (size == 2)
            val2 = (int) *SHORTP (cp, i +2);
        else if (size == 4)
            val2 = (int) *LONGP (cp, i +4);
        fval = (double) val1 * fac1 + (double) val2 * fac2;
        if (fval > maxval)
            fval = maxval;
        else if (fval < -maxval)
            fval = -maxval;
        val1 = (int) fval;
        if (size == 1)
            *CHARP (ncp, i / 2) = (signed char) val1;
        else if (size == 2)
            *SHORTP (ncp, i / 2) = (short) val1;
        else if (size == 4)
            *LONGP (ncp, i / 2) = (Py_Int32) val1;
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="876" endline="927" pcid="18"><![CDATA[
static PyObject *audioop_add (PyObject *self, PyObject *args) {
    signed char *cp1, *cp2, *ncp;
    int len1, len2, size, val1 = 0, val2 = 0, maxval, newval;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#s#i:add", &cp1, &len1, &cp2, &len2, &size))
        return 0;
    if (len1 != len2) {
        PyErr_SetString (AudioopError, "Lengths should be the same");
        return 0;
    }
    if (size == 1)
        maxval = 0x7f;
    else if (size == 2)
        maxval = 0x7fff;
    else if (size == 4)
        maxval = 0x7fffffff;
    else {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len1);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len1; i += size) {
        if (size == 1)
            val1 = (int) *CHARP (cp1, i);
        else if (size == 2)
            val1 = (int) *SHORTP (cp1, i);
        else if (size == 4)
            val1 = (int) *LONGP (cp1, i);
        if (size == 1)
            val2 = (int) *CHARP (cp2, i);
        else if (size == 2)
            val2 = (int) *SHORTP (cp2, i);
        else if (size == 4)
            val2 = (int) *LONGP (cp2, i);
        newval = val1 + val2;
        if (newval > maxval)
            newval = maxval;
        else if (newval < -maxval)
            newval = -maxval;
        else if (size == 4 && (newval ^ val1) < 0 && (newval ^ val2) < 0)
            newval = val1 > 0 ? maxval : -maxval;
        if (size == 1)
            *CHARP (ncp, i) = (signed char) newval;
        else if (size == 2)
            *SHORTP (ncp, i) = (short) newval;
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) newval;
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="929" endline="963" pcid="19"><![CDATA[
static PyObject *audioop_bias (PyObject *self, PyObject *args) {
    signed char *cp, *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    int bias;
    if (!PyArg_ParseTuple (args, "s#ii:bias", &cp, &len, &size, &bias))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = (int) *CHARP (cp, i);
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = (int) *LONGP (cp, i);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val + bias);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val + bias);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val + bias);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1303" endline="1334" pcid="26"><![CDATA[
static PyObject *audioop_lin2alaw (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2alaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_linear2alaw (val);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="965" endline="1000" pcid="20"><![CDATA[
static PyObject *audioop_reverse (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#i:reverse", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        j = len - i - size;
        if (size == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1235" endline="1266" pcid="24"><![CDATA[
static PyObject *audioop_lin2ulaw (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, val = 0;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:lin2ulaw", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len / size);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        *ncp++ = st_14linear2ulaw (val);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1268" endline="1301" pcid="25"><![CDATA[
static PyObject *audioop_ulaw2lin (PyObject *self, PyObject *args) {
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:ulaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_ulaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1002" endline="1036" pcid="21"><![CDATA[
static PyObject *audioop_lin2lin (PyObject *self, PyObject *args) {
    signed char *cp;
    unsigned char *ncp;
    int len, size, size2, val = 0;
    PyObject *rv;
    int i, j;
    if (!PyArg_ParseTuple (args, "s#ii:lin2lin", &cp, &len, &size, &size2))
        return 0;
    if ((size != 1 && size != 2 && size != 4) || (size2 != 1 && size2 != 2 && size2 != 4)) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, (len / size) * size2);
    if (rv == 0)
        return 0;
    ncp = (unsigned char *) PyString_AsString (rv);
    for (i = 0, j = 0; i < len; i += size, j += size2) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        if (size2 == 1)
            *CHARP (ncp, j) = (signed char) (val >> 8);
        else if (size2 == 2)
            *SHORTP (ncp, j) = (short) (val);
        else if (size2 == 4)
            *LONGP (ncp, j) = (Py_Int32) (val << 16);
    }
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1336" endline="1369" pcid="27"><![CDATA[
static PyObject *audioop_alaw2lin (PyObject *self, PyObject *args) {
    unsigned char *cp;
    unsigned char cval;
    signed char *ncp;
    int len, size, val;
    PyObject *rv;
    int i;
    if (!PyArg_ParseTuple (args, "s#i:alaw2lin", &cp, &len, &size))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    rv = PyString_FromStringAndSize (NULL, len *size);
    if (rv == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (rv);
    for (i = 0; i < len * size; i += size) {
        cval = *cp++;
        val = st_alaw2linear16 (cval);
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (val >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (val);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (val << 16);
    }
    return rv;
}
]]></CloneFragment>
</CloneGroup>
<CloneGroup groupid="10" nfragments="2" type="Type-3">
<CloneFragment file="/audioop.c.ifdefed" startline="1371" endline="1478" pcid="28"><![CDATA[
static PyObject *audioop_lin2adpcm (PyObject *self, PyObject *args) {
    signed char *cp;
    signed char *ncp;
    int len, size, val = 0, step, valpred, delta, index, sign, vpdiff, diff;
    PyObject *rv, *state, *str;
    int i, outputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:lin2adpcm", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    str = PyString_FromStringAndSize (NULL, len / (size * 2));
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    step = stepsizeTable[index];
    bufferstep = 1;
    for (i = 0; i < len; i += size) {
        if (size == 1)
            val = ((int) *CHARP (cp, i)) << 8;
        else if (size == 2)
            val = (int) *SHORTP (cp, i);
        else if (size == 4)
            val = ((int) *LONGP (cp, i)) >> 16;
        diff = val - valpred;
        sign = (diff < 0) ? 8 : 0;
        if (sign)
            diff = (-diff);
        delta = 0;
        vpdiff = (step >> 3);
        if (diff >= step) {
            delta = 4;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 2;
            diff -= step;
            vpdiff += step;
        }
        step >>= 1;
        if (diff >= step) {
            delta |= 1;
            vpdiff += step;
        }
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        delta |= sign;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        step = stepsizeTable[index];
        if (bufferstep) {
            outputbuffer = (delta << 4) & 0xf0;
        }
        else {
            *ncp++ = (delta & 0x0f) | outputbuffer;
        }
        bufferstep = !bufferstep;
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
]]></CloneFragment>
<CloneFragment file="/audioop.c.ifdefed" startline="1480" endline="1568" pcid="29"><![CDATA[
static PyObject *audioop_adpcm2lin (PyObject *self, PyObject *args) {
    signed char *cp;
    signed char *ncp;
    int len, size, valpred, step, delta, index, sign, vpdiff;
    PyObject *rv, *str, *state;
    int i, inputbuffer = 0, bufferstep;
    if (!PyArg_ParseTuple (args, "s#iO:adpcm2lin", &cp, &len, &size, &state))
        return 0;
    if (size != 1 && size != 2 && size != 4) {
        PyErr_SetString (AudioopError, "Size should be 1, 2 or 4");
        return 0;
    }
    if (state == Py_None) {
        valpred = 0;
        step = 7;
        index = 0;
    }
    else if (!PyArg_ParseTuple (state, "ii", &valpred, &index))
        return 0;
    str = PyString_FromStringAndSize (NULL, len *size * 2);
    if (str == 0)
        return 0;
    ncp = (signed char *) PyString_AsString (str);
    step = stepsizeTable[index];
    bufferstep = 0;
    for (i = 0; i < len * size * 2; i += size) {
        if (bufferstep) {
            delta = inputbuffer & 0xf;
        }
        else {
            inputbuffer = *cp++;
            delta = (inputbuffer >> 4) & 0xf;
        }
        bufferstep = !bufferstep;
        index += indexTable[delta];
        if (index < 0)
            index = 0;
        if (index > 88)
            index = 88;
        sign = delta & 8;
        delta = delta & 7;
        vpdiff = step >> 3;
        if (delta & 4)
            vpdiff += step;
        if (delta & 2)
            vpdiff += step >> 1;
        if (delta & 1)
            vpdiff += step >> 2;
        if (sign)
            valpred -= vpdiff;
        else
            valpred += vpdiff;
        if (valpred > 32767)
            valpred = 32767;
        else if (valpred < -32768)
            valpred = -32768;
        step = stepsizeTable[index];
        if (size == 1)
            *CHARP (ncp, i) = (signed char) (valpred >> 8);
        else if (size == 2)
            *SHORTP (ncp, i) = (short) (valpred);
        else if (size == 4)
            *LONGP (ncp, i) = (Py_Int32) (valpred << 16);
    }
    rv = Py_BuildValue ("(O(ii))", str, valpred, index);
    Py_DECREF (str);
    return rv;
}
]]></CloneFragment>
</CloneGroup>
</Clones>
</SimCad>